;+
;   General event handler for the MrTopLevelBase widget class. Its purpose is to forward
;   the different events generated by the XManager to their respective event handling
;   methods.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrDrawWidget_Drag_Notify, destination, source, x, y, modifiers, default
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Type of event that was generated.
    event_name = size(event, /SNAME)
    widget_control, event.top, GET_UVALUE=oTLB
    oTLB -> GetProperty, DRAG_NOTIFY_EVENT_HANDLER=drag_notify
    
    ;Forward the event.
    Call_Method, drag_notify.method, drag_notify.object, destination, source, x, y, modifiers, default
end


;+
;   General event handler for the MrTopLevelBase widget class. Its purpose is to forward
;   the different events generated by the XManager to their respective event handling
;   methods.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrDrawWidget_Event_Pro, event
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Type of event that was generated.
    event_name = size(event, /SNAME)
    widget_control, event.top, GET_UVALUE=oTLB
    
    ;Types of events
    event_type = ['MOUSE_DOWN', 'MOUSE_UP', 'MOUSE_MOTION', 'VIEWPORT_MOVE', 'EXPOSE', $
                  'KBRD_ASCII', 'KBRD', 'MOUSE_WHEEL']
        
    ;Forward the event to the event-handling method
    case event_type[event.type] of
        'MOUSE_DOWN': begin
            oTLB -> GetProperty, BUTTON_EVENT_HANDLER=button_events
            if obj_valid(button_events.object) then $
                Call_Method, button_events.method, button_events.object, event
        endcase
        
        'MOUSE_UP': begin
            oTLB -> GetProperty, BUTTON_EVENT_HANDLER=button_events
            if obj_valid(button_events.object) then $
                Call_Method, button_events.method, button_events.object, event
        endcase
        
        'MOUSE_MOTION': begin
            oTLB -> GetProperty, MOTION_EVENT_HANDLER=motion_events
            if obj_valid(motion_events.object) then $
                Call_Method, motion_events.method, motion_events.object, event
        endcase
        
        'VIEWPORT_MOVE': begin
            oTLB -> GetProperty, VIEWPORT_EVENT_HANDLER=viewport_events
            if obj_valid(expose_events.object) then $
                Call_Method, expose_events.method, expose_events.object, event
        endcase
        
        'EXPOSE': begin
            oTLB -> GetProperty, EXPOSE_EVENT_HANDLER=expose_events
            if obj_valid(expose_events.object) then $
                Call_Method, expose_events.method, expose_events.object, event
        endcase
        
        'KBRD_ASCII': begin
            oTLB -> GetProperty, KEYBOARD_EVENT_HANDLER=keyboard_events
            if obj_valid(keyboard_events.object) then $
                Call_Method, keyboard_events.method, keyboard_events.object, event
        endcase
        
        'KBRD': begin
            oTLB -> GetProperty, KEYBOARD_EVENT_HANDLER=keyboard_events
            if obj_valid(keyboard_events.object) then $
                Call_Method, keyboard_events.method, keyboard_events.object, event
        endcase
        
        'MOUSE_WHEEL': begin
            oTLB -> GetProperty, WHEEL_EVENT_HANDLER=wheel_events
            if obj_valid(wheel_events.object) then $
                Call_Method, wheel_events.method, wheel_events.object, event
        endcase
    endcase
end


;+
;   Event handling function for Event_Func.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
function MrDrawWidget_Event_Func, event
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return, 0
    endif
    
    ;Type of event that was generated.
    event_name = size(event, /SNAME)
    widget_control, event.top, GET_UVALUE=oTLB
    
    ;Types of events
    event_type = ['MOUSE_DOWN', 'MOUSE_UP', 'MOUSE_MOTION', 'VIEWPORT_MOVE', 'EXPOSE', $
                  'KBRD_ASCII', 'KBRD', 'MOUSE_WHEEL']
        
    ;Forward the event to the event-handling method
    case event_type[event.type] of
        'MOUSE_DOWN': begin
            oTLB -> GetProperty, BUTTON_EVENT_HANDLER=button_events
            if obj_valid(button_events.object) then $
                result = Call_Method(button_events.method, button_events.object, event)
        endcase
        
        'MOUSE_UP': begin
            oTLB -> GetProperty, BUTTON_EVENT_HANDLER=button_events
            if obj_valid(button_events.object) then $
                result = Call_Method(button_events.method, button_events.object, event)
        endcase
        
        'MOUSE_MOTION': begin
            oTLB -> GetProperty, MOTION_EVENT_HANDLER=motion_events
            if obj_valid(motion_events.object) then $
                result = Call_Method(motion_events.method, motion_events.object, event)
        endcase
        
        'VIEWPORT_MOVE': begin
            oTLB -> GetProperty, VIEWPORT_EVENT_HANDLER=viewport_events
            if obj_valid(expose_events.object) then $
                result = Call_Method(expose_events.method, expose_events.object, event)
        endcase
        
        'EXPOSE': begin
            oTLB -> GetProperty, EXPOSE_EVENT_HANDLER=expose_events
            if obj_valid(expose_events.object) then $
                result = Call_Method(expose_events.method, expose_events.object, event)
        endcase
        
        'KBRD_ASCII': begin
            oTLB -> GetProperty, KEYBOARD_EVENT_HANDLER=keyboard_events
            if obj_valid(keyboard_events.object) then $
                result = Call_Method(keyboard_events.method, keyboard_events.object, event)
        endcase
        
        'KBRD': begin
            oTLB -> GetProperty, KEYBOARD_EVENT_HANDLER=keyboard_events
            if obj_valid(keyboard_events.object) then $
                result = Call_Method(keyboard_events.method, keyboard_events.object, event)
        endcase
        
        'MOUSE_WHEEL': begin
            oTLB -> GetProperty, WHEEL_EVENT_HANDLER=wheel_events
            if obj_valid(wheel_events.object) then $
                result = Call_Method(wheel_events.method, wheel_events.object, event)
        endcase
        
        else: result = 0
    endcase
    
    return, result
end


;*****************************************************************************************************
;+
; NAME:
;       DRAWWIDGET::DRAW
;
; PURPOSE:
;
;       This method draws the contents of the draw widget object's container in the draw widget window.
;       It does this by calling the DRAW methods of any objects found in its container object.
;;
; SYNTAX:
;
;       thisDrawObj -> Draw
;
; ARGUMENTS:
;
;       None.
;
; KEYWORDS:
;
;       BACKGROUND_COLOR: Set this keyword to the name of the background color. Used
;                         only when erasing window contents. On 8-bit displays, this
;                         will load a color in !P.BACKGROUND. The color "BLACK" by default.
;
;       ERASE_WINDOW:     Set this keyword to erase the window before drawing contents.
;
;       HOURGLASS:        Set this keyword to enable the hourglass cursor for the draw operation.
;
;       REQUESTER:        This optional keyword is set to the object that requests a DRAW of the
;                         DrawWidget. This is helpful sometimes when DRAWWIDGET_DRAW messages
;                         are received by other objects. The object reference is passed on as
;                         the DATA in the DRAWWIDGET_DRAW message.
;
;       TARGET_WINDOW:    Normally the draw widget draws into its own window. But, sometimes you
;                         want the draw widget to draw somewhere else. Setting this keyword to
;                         another DRAWWIDGET or PIXMAPWIDGET object reference allows graphics
;                         to be drawn there.
;
;       TARGETS:          Typically, calling the DRAW method of a DrawWidget will call the DRAW
;                         method of any objects in its container. However, if the TARGETS keyword
;                         is set to an object reference (or array of object references), only these
;                         objects will be drawn. This would allow you, for example, to re-draw only
;                         a single image object in a window with several image objects.
;
;       _EXTRA:           Any extra keywords appropriate for superclass DRAW methods.
;-
;*****************************************************************************************************
PRO MrDrawWidget::Draw, $
 BACKGROUND_COLOR=background_color, $
 ERASE_WINDOW=erase_window, $
 HOURGLASS=hourglass, $
 REQUESTER=requester, $
 TARGET_WINDOW=target_window, $
 TARGETS=targets, $
_EXTRA=extraKeywords
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    ;do not draw anything?
    if self._refresh eq 0 then return

    ;make sure the window is valid
    if (WindowAvailable(self._winID) eq 0) then message, 'Draw widget does not have a valid window id. Try realizing it.'

    ; check keywords.
    hourglass = keyword_set(hourglass)
    erase_window = keyword_set(erase_window)
    if n_elements(background_color) eq 0 then background_color = self._background

    ;Enable the hourglass mouse cursor, if needed.
    if hourglass then widget_control, /HOURGLASS

    ;If the device supports windows, switch to the draw window.
    if (!d.flags and 256) ne 0 then begin
        wset, self._winid

        ;Need the window erased?
;        if (erase_window or self._erasewindow) then erase, color=cgcolor(background_color, !p.background)
   endif
   
    ;Get all objects from the container
    allObj = self -> Get(/ALL, COUNT=nObj)
    
    ;Draw all of the objects.
    for i = 0, nObj - 1 do allObj[i] -> Draw
end


;+
;   The purpose of this method is to erase the draw window.
;-
pro MrDrawWidget::Erase
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Default background color
    if n_elements(color) eq 0 then color = self._background
    
    ;Erase the window.
    if (!d.flags and 256) ne 0 then wset, self._winID
    cgErase, color=cgcolor(self_background)
end


;+
;   Event handling method for Notify_Realize
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrDrawWidget::Notify_Realize, id
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Get the window ID of the draw widget
    widget_control, id, GET_VALUE=winID
    self._winID = winID

    ;Set the name of the window to include with window number.
    widget_control, id, TLB_SET_TITLE='MrDrawWidget (' + strtrim(winID,2) + ')'
    
    ;Draw as soon as the window is visible
    self -> Draw
end


;*****************************************************************************************************
;+
; NAME:
;       DRAWWIDGET::RESIZE
;
; PURPOSE:
;
;       This method resizes the canvas area of the draw widget.
;;
; SYNTAX:
;
;       thisDrawObj -> Resize, xsize, ysize
;
; ARGUMENTS:
;
;       XSIZE:    The new X size of the canvas area of the draw widget, in pixels.
;
;       YSIZE:    The new Y size of the canvas area of the draw widget, in pixels.
;
; KEYWORDS:
;
;       DRAW:     Set this keyword to call the draw method when the draw widget
;                 resizing is completed.
;
;       SCREEN:   Normally, the XSIZE and YSIZE keywords apply to the draw widget canvas.
;                 If the SCREEN keyword is set, the keywords apply to the screen coordinates
;                 of the draw widget. (It's actual size on the display. Usually about 6 pixels
;                 larger than the canvas.)
;
;       VIEWPORT: Normally, the XSIZE and YSIZE keywords apply to the draw widget canvas.
;                 If the VIEWPORT keyword is set, the keywords apply to the viewport size
;                 of the draw widget.
;
;       _EXTRA:   Any extra keywords appropriate for the DRAW method.
;-
;*****************************************************************************************************
PRO MrDrawWidget::Resize, xsize, ysize, $
 DRAW=draw, $
 SCREEN=screen, $
 VIEWPORT=viewport, $
_EXTRA=extraKeywords
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
        if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    IF N_Elements(xsize) EQ 0 THEN Message, "XSIZE parameter is missing."
    IF N_Elements(ysize) EQ 0 THEN Message, "YSIZE parameter is missing."

    CASE 1 OF
        KEYWORD_SET(screen): Widget_Control, self._id, Scr_XSize=xsize, Scr_YSize=ysize
        KEYWORD_SET(viewport): Widget_Control, self._id, XSize=xsize, YSize=ysize
        ELSE: Widget_Control, self._id, Draw_XSize=xsize, Draw_YSize=ysize
    ENDCASE

    IF Keyword_Set(draw) THEN self -> Draw, _Extra=extraKeywords
END


;+
;   The purpose of this method it enable or diable refreshing of the display.
;
; :Keywords:
;       DISABLE:            in, optional, type=boolean, default=0
;                           If set, refreshing of the draw window will be disabled.
;-
pro MrDrawWidget::Refresh, $
DISABLE=disable
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Enable or disable.
    self._refresh = ~keyword_set(disable)
    
    ;Re-draw the window contents.
    if self._refresh then self -> Draw
end


;+
;   Event handling method for TLB_Size_Events. This method is only called if PARENT was
;   not provided when the draw widget was made.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrDrawWidget::TLB_Resize_Events, event
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    ;Subtract the height of the menu and status bars from the size of the top level base
    xNew = event.x
    yNew = event.y
    
    ;Set the new size of the draw widget
    self -> Resize, xNew, yNew
;    self.xsize = xNew
;    self.ysize = yNew

    ;Draw the plot to the new size
    self -> Draw
end


;+
;
;-
PRO MrDrawWidget::GetProperty, $
 BACKGROUND=background, $
 BUTTON_EVENTS=button_events, $
 CONTEXT_EVENTS=context_events, $
 EXPOSE_EVENTS=expose_events, $
 KEYBOARD_EVENTS=keyboard_events, $
 MOTION_EVENTS=motion_events, $
 TOOLTIP=tooltip, $
 VIEWPORT_EVENTS=viewport_events, $
 WHEEL_EVENTS=wheel_events, $
 WINDOWID=windowID, $

 ;Method Event Handling
 BUTTON_EVENT_HANDLER=button_EH, $
 CONTEXT_EVENT_HANDLER=context_EH, $
 EXPOSE_EVENT_HANDLER=expose_EH, $
 KEYBOARD_EVENT_HANDLER=keyboard_EH, $
 MOTION_EVENT_HANDLER=motion_EH, $
 VIEWPORT_EVENT_HANDLER=viewport_EH, $
 WHEEL_EVENT_HANDLER=wheel_EH, $
_REF_EXTRA=extra
   compile_opt strictarr

    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    ;Active Events
    if (widget_info (self._id, /VALID_ID)) then begin
        if arg_present(windowid)        then widget_control, self._id, GET_VALUE=windowID
        if arg_present(button_events)   then button_events   = widget_info(self._id, /DRAW_BUTTON_EVENTS)
        if arg_present(expose_events)   then expose_events   = widget_info(self._id, /DRAW_EXPOSE_EVENTS)
        if arg_present(motion_events)   then motion_events   = widget_info(self._id, /DRAW_MOTION_EVENTS)
        if arg_present(viewport_events) then viewport_events = widget_info(self._id, /DRAW_VIEWPORT_EVENTS)
        if arg_present(keyboard_events) then keyboard_events = widget_info(self._id, /DRAW_KEYBOARD_EVENTS)
        if arg_present(tooltip)         then tooltip         = widget_info(self._id, /TOOLTIP)
        if arg_present(wheel_events)    then wheel_events    = widget_info(self._id, /DRAW_WHEEL_EVENTS)
    endif
   
    ;Method Event Handlers
    if arg_present(button_EH)   then button_EH   = self._button_event_handler
    if arg_present(context_EH)  then context_EH  = self._context_event_handler
    if arg_present(expose_EH)   then expose_EH   = self._expose_event_handler
    if arg_present(keyboard_EH) then keyboard_EH = self._keyboard_event_handler
    if arg_present(motion_EH)   then motion_EH   = self._motion_event_handler
    if arg_present(viewport_EH) then viewport_EH = self._viewport_event_handler
    if arg_present(wheel_EH)    then wheel_EH    = self._wheel_event_handler

    if arg_present(context_events) then context_events = widget_info(self._id, /CONTEXT_EVENTS)
    if arg_present(background)     then background = self._background
    
    ;Superclass Properties
    if n_elements(extra) gt 0 then self -> MrWidgetAtom::GetProperty, _STRICT_EXTRA=extra
end


;+
;
;-
PRO MrDrawWidget::SetProperty, $
 BACKGROUND=background, $
 BUTTON_EVENTS=button_events, $
 CONTEXT_EVENTS=context_events, $
 ERASE_WINDOW=erase_window, $
 EXPOSE_EVENTS=expose_events, $
 IGNORE_ACCELERATORS=ignore_accelerators, $
 INPUT_FOCUS=input_focus, $
 KEYBOARD_EVENTS=keyboard_events, $
 MOTION_EVENTS=motion_events, $
 SCREEN=screen, $
 SET_DRAW_VIEW=set_draw_view, $
 TOOLTIP=tooltip, $
 VIEWPORT_EVENTS=viewport_events, $
 VIEWPORT_SIZE=viewport_size, $
 WHEEL_EVENTS=wheel_events, $
 WINDOWID=windowID, $
 XSIZE=xsize, $
 YSIZE=ysize, $

 ;Method Event Handling
 BUTTON_EVENT_HANDLER=button_EH, $
 CONTEXT_EVENT_HANDLER=context_EH, $
 EXPOSE_EVENT_HANDLER=expose_EH, $
 KEYBOARD_EVENT_HANDLER=keyboard_EH, $
 MOTION_EVENT_HANDLER=motion_EH, $
 VIEWPORT_EVENT_HANDLER=viewport_EH, $
 WHEEL_EVENT_HANDLER=wheel_EH, $
_REF_EXTRA=extra
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    ; Make sure you have a valid widget here.
    IF Widget_Info(self._id, /Valid_ID) NE 1 THEN RETURN
    
    IF N_Elements(windowID) GT 0 THEN self._winID = windowID

    ; Set properties with Widget_Control.
    IF (N_ELEMENTS (button_events) GT 0)       THEN WIDGET_CONTROL, self._id, DRAW_BUTTON_EVENTS=Keyword_Set(button_events)
    IF N_Elements(context_events) NE 0         THEN WIDGET_CONTROL, self._id, CONTEXT_EVENTS=Keyword_Set(context_events)
    IF (N_ELEMENTS (erase_window) GT 0)        THEN self._eraseWindow = Keyword_Set(erase_window)
    IF (N_ELEMENTS (expose_events) GT 0)       THEN WIDGET_CONTROL, self._id, DRAW_EXPOSE_EVENTS=Keyword_Set(expose_events)
    IF (N_ELEMENTS (ignore_accelerators) GT 0) THEN WIDGET_CONTROL, self._id, IGNORE_ACCELERATORS=Keyword_Set(ignore_accelerators)
    IF (N_ELEMENTS (background) GT 0)          THEN self._background = background
    IF (N_ELEMENTS (keyboard_events) GT 0)     THEN WIDGET_CONTROL, self._id, DRAW_KEYBOARD_EVENTS=keyboard_events
    IF (N_ELEMENTS (motion_events) GT 0)       THEN WIDGET_CONTROL, self._id, DRAW_MOTION_EVENTS=Keyword_Set(motion_events)
    IF (N_ELEMENTS (set_draw_view) GT 0)       THEN WIDGET_CONTROL, self._id, SET_DRAW_VIEW=set_draw_view
    IF (N_ELEMENTS (viewport_events) GT 0)     THEN WIDGET_CONTROL, self._id, DRAW_VIEWPORT_EVENTS=Keyword_Set(viewport_events)
    IF (N_ELEMENTS (input_focus) GT 0)         THEN WIDGET_CONTROL, self._id, INPUT_FOCUS=Keyword_Set(input_focus)
    IF N_ELEMENTS (tooltip) NE 0               THEN Widget_Control, self._ID, TOOLTIP=tooltip
    IF N_ELEMENTS (wheel_events) NE 0          THEN Widget_Control, self._ID, DRAW_WHEEL_EVENTS=Keyword_Set(wheel_events)
    IF N_ELEMENTS (xsize) NE 0                 THEN resizeFlag = 1
    IF N_ELEMENTS (ysize) NE 0                 THEN resizeFlag = 1

    ;Method Event Handlers
    if n_elements(context_EH)  gt 0 then self._context_event_handler  = context_EH
    if n_elements(expose_EH)   gt 0 then self._expose_event_handler   = expose_EH
    if n_elements(keyboard_EH) gt 0 then self._keyboard_event_handler = keyboard_EH
    if n_elements(motion_EH)   gt 0 then self._motion_event_handler   = motion_EH
    if n_elements(viewport_EH) gt 0 then self._viewport_event_handler = viewport_EH
    if n_elements(wheel_EH)    gt 0 then self._wheel_event_handler    = wheel_EH

    if n_elements(extra) gt 0 then self -> MrWidgetAtom::SetProperty, _STRICT_EXTRA=extra
END


;+
;   This is the DRAWWIDGET object class initialization method
;
; :Params:
;
;       PARENT:         An object reference to a WIDGETATOM-subclassed object.
;                           This is the same as using the PARENT keyword.
;
; :Keywords:
;
;       APP_SCROLL:      A memory-saving way of scrolling draw widgets. See WIDGET_DRAW documentation.
;
;       BUTTON_EVENTS:   Set this keyword to enable widget button events in the draw widget.
;
;       COLOR_OBJECT:    Use this keyword to load a COLORTOOL object for setting up colors
;                        for data display.
;
;       CONTEXT_EVENTS:  Set this keyword to turn context events on for this widget object..
;
;       COORD_OBJECT:    Use this keyword to load a CATCOORD object for setting up
;                        the data coordinate system for data display.
;
;       ERASE_WINDOW:    Set this keyword to cause the draw widget to execute an ERASE before drawing.
;
;       EXPOSE_EVENTS:   Set this keyword to enable widget expose events in the draw widget.
;
;       FRAME:           Create a frame this many pixels wide around the widget.
;
;       IGNORE_ACCELERATORS: Set this keyword to specify what WIDGET_BUTTON accelerators are to be
;                        ignored when this draw widget has keyboard focus. Setting IGNORE_ACCELERATORS
;                        allows a defined list of accelerators to be processed by the draw widget instead
;                        of by the conflicting accelerated button. Valid values are:
;
;                             A string or string array containing any value that is legal for the
;                             ACCELERATOR keyword for BUTTONWIDGET, or
;
;                             1 -- Indicating that all accelerators should be ignored.
;
;                        Ordinarily, accelerators are processed before keyboard events reach the
;                        widget that has the keyboard focus. Setting IGNORE_ACCELERATORS allows a
;                        defined list of accelerators to be processed by the draw widget instead of
;                        by associated buttons or menu items. Once the draw widget loses focus, all
;                        specified accelerators are automatically re-enabled.
;
;       INITIAL_COLOR:   The name of the initial color for the draw widget. Used when realized and
;                        if the draw widget is set up to erase before display (i.e., ERASE_WINDOW=1).
;
;       KEYBOARD_EVENTS: Set this keyword to enable keyboard events for this widget. Setting
;                        the value to 1 will enable "normal" keys. Setting the value to 2 will enable
;                        modifier keys. See the IDL documenation for WIDGET_DRAW for details.
;
;       MOTION_EVENTS:   Set this keyword to enable widget motion events in the draw widget.
;
;       NODRAW:          Set this keyword to prohibit re-drawing via the DRAW method.
;
;       PARENT:          An object reference to a WIDGETATOM-subclassed object.
;
;       REFRESHBUFFER:   An object reference to a PIXMAPWIDGET object that can serve to refresh the
;                        draw widget display. The draw widget takes no parental interest in this object
;                        and doesn't destroy it when the draw widget is destroyed. The refresh buffer is
;                        accessed via the REFRESH method. If no buffer is present, the REFRESH method
;                        simply calls the DRAW method for the object.
;
;       RETAIN:          Set this keyword to determine how backing store is handled. See IDL WIDGET_DRAW
;                        documentation for details. Set to 1 by default for Windows machines and to 2 otherwise.
;
;       SCR_XSIZE:       Set the screen X size of the base to this many pixels. (Use discouraged.)
;
;       SCR_YSIZE:       Set the screen Y size of the base to this many pixels. (Use discouraged.)
;
;       SCROLL:          Set this keyword to add scroll bars to the draw widget.
;
;       TOOLTIP:         Set this keyword to a string that will be displayed if the cursor hovers
;                        over the draw widget.
;
;       UNITS:           The units for measurments. The default is 0 for pixels. Other values are
;                        1 for inches, and 2 for centimeters.
;
;       VIEWPORT_EVENTS: Set this keyword to enable widget viewport scroll events in the draw widget.
;
;       WHEEL_EVENTS:    Set this keyword to enable wheel events in the draw widget.
;
;       X_SCROLL_SIZE:   The X size (pixels) of the scrollable window area.
;
;       XOFFSET:         The horizontal space (pixels) from upper left corner of the display.
;
;       XSIZE:           The X size of the widget. (300 pixels by default.)
;
;       Y_SCROLL_SIZE:   The Y size (pixels) of the scrollable window area
;
;       YOFFSET:         The vertical space (pixels) from upper left corner of the display.
;
;       YSIZE:           The Y size of the widget. (300 pixels by default.)

;       _EXTRA:          Any keyword appropriate for the superclass INIT methods.
;
;-
function MrDrawWidget::init, parent,   $
 APP_SCROLL=app_scroll, $
 BUTTON_EVENTS=button_events, $
 CLASSNAME=classname, $
 COLOR_MODEL=color_model, $
 COLORS=colors, $
 DRAG_NOTIFY=drag_notify, $
 DROP_EVENTS=drop_events, $
 EXPOSE_EVENTS=expose_events, $
 FRAME=frame, $
 GROUP_LEADER=group_leader, $
 IGNORE_ACCELERATORS=ignore_accelerators, $
 KEYBOARD_EVENTS=keyboard_events, $
 MOTION_EVENTS=motion_events, $
 NOTIFY_REALIZE=notify_realize, $
 RENDERER=renderer, $
 RESOURCE_NAME=resource_name, $
 RETAIN=retain, $
 SCR_XSIZE=scr_xsize, $
 SCR_YSIZE=scr_ysize, $
 SCROLL=scroll, $
 TOOLTIP=tooltip, $
 UNITS=units, $
 VIEWPORT_EVENTS=viewport_events, $
 WHEEL_EVENTS=wheel_events, $
 X_SCROLL_SIZE=x_scroll_size, $
 XOFFSET=xoffset, $
 XSIZE=xsize, $
 Y_SCROLL_SIZE=y_scroll_size, $
 YOFFSET=yoffset, $
 YSIZE=ysize, $
_REF_EXTRA=extra
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return, 0
    endif

;---------------------------------------------------------------------
;Defaults ////////////////////////////////////////////////////////////
;---------------------------------------------------------------------
;    self._nodraw = keyword_set(nodraw)
    if n_elements(xsize) eq 0 then xsize = 300
    if n_elements(ysize) eq 0 then ysize = 300
    if n_elements(background) eq 0 then self._background = 'black' else self._background = background
    if n_elements(retain) eq 0 then retain=(!version.os_family eq 'windows') ? 1 : 2

;---------------------------------------------------------------------
;Parent //////////////////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;Create a MrTopLevelBase object to use as the parent
    if n_elements(parent) eq 0 then begin
        self._oTLB = obj_new('MrTopLevelBase', TITLE='MrDrawWidget', $
                             TLB_SIZE_EVENTS={object: self, method: 'TLB_Resize_Events'})
        self._oTLB -> GetProperty, ID=parentID

    ;Use an existing MrTopLevelBase object as the parent.
    endif else if size(parent, /TNAME) eq 'OBJREF' then begin
        tf_MrTLB = cgObj_IsA(parent, 'MrTopLevelBase')
        if tf_MrTLB eq 0 then message, 'Only "MrTopLevelBase" classes may be given as a parent.'
        self._oTLB = parent
        self._oTLB -> GetProperty, ID=parentID
    
    ;Use a normal widget base as the parent.
    endif else begin
        self._oTLB = parent
        parentID = parent
    endelse
    
;---------------------------------------------------------------------
;Create the Draw Widget //////////////////////////////////////////////
;---------------------------------------------------------------------
    self._id = widget_draw( parentID,   $
                            APP_SCROLL          = app_scroll, $
                            CLASSNAME           = classname, $
                            COLOR_MODEL         = color_model, $
                            COLORS              = colors, $
                            FRAME               = frame, $
                            GROUP_LEADER        = group_leader, $
                            IGNORE_ACCELERATORS = ignore_accelerators, $
                            RENDERER            = renderer, $
                            RESOURCE_NAME       = resource_name, $
                            RETAIN              = retain, $
                            SCR_XSIZE           = scr_xsize, $
                            SCR_YSIZE           = scr_ysize, $
                            SCROLL              = scroll, $
                            TOOLTIP             = tooltip, $
                            UNITS               = units, $
                            X_SCROLL_SIZE       = x_scroll_size, $
                            XOFFSET             = xoffset, $
                            XSIZE               = xsize, $
                            Y_SCROLL_SIZE       = y_scroll_size, $
                            YOFFSET             = yoffset, $
                            YSIZE               = ysize $
                          )

;---------------------------------------------------------------------
;Event Handling //////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;
    ; If a structure with an object and method was provided for any of the event
    ; handling procedures or functions, then interally call a function that will
    ; forward the events to the proper methods.
    ;
    
    ;Button Events
    case size(button_events, /TNAME) of
        'STRUCT': begin
            self._button_event_handler = button_events
            widget_control, self._id, DRAW_BUTTON_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DRAW_BUTTON_EVENTS=keyword_set(button_events)
    endcase
    
    ;Drag Notify Events
    case size(drag_notify, /TNAME) of
        'STRUCT': begin
            self._drag_notify_event_handler = drag_notify
            widget_control, self._id, DRAG_NOTIFY='MrDrawWidget_Drag_Notify'
        endcase
        'STRING': widget_control, self._id, DRAG_NOTIFY=drag_notify
        'UNDEFINED': ;Do nothing
        else: message, 'DRAG_NOTIFY must be a string or a structure.'
    endcase
    
    ;Drop Events
    case size(drop_events, /TNAME) of
        'STRUCT': begin
            self._drop_event_handler = drop_events
            widget_control, self._id, DROP_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DROP_EVENTS=keyword_set(drop_events)
    endcase
    
    ;Expose Events
    case size(expose_events, /TNAME) of
        'STRUCT': begin
            self._expose_event_handler = expose_events
            widget_control, self._id, DRAW_EXPOSE_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DRAW_EXPOSE_EVENTS=keyword_set(expose_events)
    endcase
    
    ;Keyboard Events
    case size(keyboard_events, /TNAME) of
        'STRUCT': begin
            self._keyboard_event_handler = keyboard_events
            widget_control, self._id, DRAW_KEYBOARD_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DRAW_KEYBOARD_EVENTS=keyboard_events
    endcase
    
    ;Motion Events
    case size(motion_events, /TNAME) of
        'STRUCT': begin
            self._motion_event_handler = motion_events
            widget_control, self._id, DRAW_MOTION_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DRAW_MOTION_EVENTS=keyword_set(motion_events)
    endcase
    
    ;Viewport Events
    case size(viewport_events, /TNAME) of
        'STRUCT': begin
            self._viewport_event_handler = viewport_events
            widget_control, self._id, DRAW_VIEWPORT_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DRAW_VIEWPORT_EVENTS=keyword_set(viewport_events)
    endcase
    
    ;Wheel Events
    case size(wheel_events, /TNAME) of
        'STRUCT': begin
            self._wheel_event_handler = wheel_events
            widget_control, self._id, DRAW_WHEEL_EVENTS=1
        endcase
        'UNDEFINED': ;Do nothing
        else: widget_control, self._id, DRAW_WHEEL_EVENTS=keyword_set(wheel_events)
    endcase
    
    ;Notify Realize -- We need to get the window id of the draw window when the widget
    ;                  window is realized.
    if n_elements(notify_realize) eq 0 $
        then notify_realize = {object: self, method: 'Notify_Realize'}

;---------------------------------------------------------------------
;More Superclasses ///////////////////////////////////////////////////
;---------------------------------------------------------------------

    if (self -> MrWidgetAtom::INIT(NOTIFY_REALIZE=notify_realize, $
                                   _STRICT_EXTRA=extra) eq 0) then $
        message, 'MrWidgetAtom could not be initialized.'

;---------------------------------------------------------------------
;Return Step /////////////////////////////////////////////////////////
;---------------------------------------------------------------------
        
    ;Set the user value of the widget as the TLB object reference.
    widget_control, self._id, SET_UVALUE=self

    ;If we created a new tlb, realize it now and register it with XManager.
    if n_elements(parent) eq 0 and obj_valid(self._oTLB) then begin
        self._oTLB -> XManager
    endif

    ; need a window erase?
;    self._erase = keyword_set(erase_window)

    return, 1
end



;+
;   The class definition statement.
;
; :Params:
;       CLASS:          out, optional, type=structure
;                       The class definition structure.
;-
pro MrDrawWidget__define_v1, class

   class = { MrDrawWidget, $
             inherits MrWidgetAtom, $
             inherits MrIDL_Container, $
             _oTLB: obj_new(), $        ;A top-level base widget object, if required.
             _winID: 0, $               ;The window ID of the draw window
             
             ;Method Event Handlers
             _drag_notify: ptr_new(), $
             _drop_event_handler:        {MrEventHandler}, $
             _button_event_handler:      {MrEventHandler}, $
             _expose_event_handler:      {MrEventHandler}, $
             _keywboard_event_handler:   {MrEventHandler}, $
             _motion_event_handler:      {MrEventHandler}, $
             _viewport_event_handler:    {MrEventHandler}, $
             _wheel_event_handler:       {MrEventHandler}, $
            
             _refresh: 0B, $            ; flag that, if set, inhibits draw method calls.
             _erase: 0B, $              ; a flag that indicates the window should be erased before drawing.
             _background: '', $         ; the name of the initial window color.
             _pixmap: obj_new() $       ; the identifier of a pixmapwidget that can carry out window refresh.
           }
end