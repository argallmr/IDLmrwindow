;+
;   General event handler for the MrTopLevelBase widget class. Its purpose is to forward
;   the different events generated by the XManager to their respective event handling
;   methods.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom_Event_Pro, event
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Get the object reference and the KILL_NOTIFY method.
    widget_control, event.id, GET_UVALUE=ORef
    
;---------------------------------------------------------------------
;Forward Events? /////////////////////////////////////////////////////
;---------------------------------------------------------------------
    ;If an event handler was provided, forward the events then return.
    ORef -> GetProperty, EVENT_HANDLER=event_handler
    if obj_valid(self._event_handler) then begin
        Call_Method, event_handler.method, event_handler.object, event
        return
    endif
        
;---------------------------------------------------------------------
;Set Object Properties ///////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;Handle tracking events -- the one event-type common to all widgets.
    case size(event, /SNAME) of
        'TRACKING_EVENTS': begin
            ORef -> GetProperty, TRACKING_HANDLER=tracking_eh
            case size(tracking_eh, /TNAME) of
                'OBJREF': Call_Method, tracking_eh.method, tracking_eh.object, event
                'STRING': if tracking_eh ne '' then Call_Procedure, tracking_eh, event
            endcase
        endcase
        
        else: ;Do nothing
    endcase
end


;+
;   Event handling function for Event_Func.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;
; :Returns:
;       RESULTS:            The result returned by the forwarding method. Returns zero (0)
;                               if the event type is unknown or an error occurred.
;-
function MrWidgetAtom_Event_Func, event
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return, 0
    endif
    
    ;Get the object reference.
    widget_control, event.id, GET_UVALUE=ORef
    
;---------------------------------------------------------------------
;Callback Object /////////////////////////////////////////////////////
;---------------------------------------------------------------------
    ;If an object event handler exists, then call it and return
    ORef -> GetProperty, EVENT_HANDLER=event_handler
    if obj_valid(event_handler) then begin
        result = Call_Method(event_handler.method, event_handler.object, event)
        return, result
    endif
    
;---------------------------------------------------------------------
;Callback Func/Method ////////////////////////////////////////////////
;---------------------------------------------------------------------
    ;Forward tracking events -- The one event-type common to all widgets.
    case size(event, /SNAME) of
        'TRACKING_EVENTS': begin
            ORef -> GetProperty, TRACKING_HANDLER=tracking_eh
            case size(tracking_eh, /TNAME) of
                'OBJREF': result = Call_Method(tracking_eh.method, tracking_eh.object, event)
                'STRING': if tracking_eh ne '' then result = Call_Function(tracking_eh, event)
            endcase
        endcase
        
        else: result = 0
    endcase
    
    ;Make sure the output is defined.
    if n_elements(result) eq 0 then result = 0
    
    return, result
end


;+
;   Event handling function for Func_Get_Value.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;
; :Returns:
;       RESULTS:            The result returned by the forwarding method. Returns zero (0)
;                               if no forwarding method exists or if an error occurred.
;-
function MrWidgetAtom_Func_Get_Value, event
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return, 0
    endif
    
    ;Get the object reference and the KILL_NOTIFY method.
    widget_control, event.id, GET_UVALUE=oRef
    oRef -> GetProperty, HANDLER_FUNC_GET_VALUE=func_get_eh
    
    ;Forward the event to the proper object method.
    case size(func_get_eh, /TNAME) of
        'OBJREF': result = Call_Method(func_get_eh.method, func_get_eh.object, event)
        'STRING': if func_get_eh ne '' then result = Call_Function(func_get_eh, event)
    endcase
    
    ;Make sure the output is defined.
    if n_elements(result) eq 0 then result = 0
    
    ;Return the results.
    return, result
end


;+
;   Event handling method for Kill_Notify Events.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom_Kill_Notify, id
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    ;Get the object reference and the KILL_NOTIFY method.
    widget_control, id, GET_UVALUE=ObjRef
    ObjRef -> GetProperty, HANDLER_KILL_NOTIFY=kill_notify_eh

    ;Forward the event to the proper procedure.
    case size(kill_notify_eh, /TNAME) of
        'STRUCT': Call_Method, kill_notify_eh.method, kill_notify_eh.object, id
        'STRING': if kill_notify_eh ne '' then Call_Procedure, kill_notify_eh, id
    endcase
end


;+
;   Event handling method for Notify_Realize Events.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom_Notify_Realize, id
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Get the object reference and the NOTIFY_REALIZE method.
    widget_control, id, GET_UVALUE=ObjRef
    ObjRef -> GetProperty, HANDLER_NOTIFY_REALIZE=notify_realize_eh

    ;Forward the event to the proper procedure.
    case size(notify_realize_eh, /TNAME) of
        'STRUCT': Call_Method, notify_realize_eh.method, notify_realize_eh.object, id
        'STRING': if notify_realize_eh ne '' then Call_Procedure, notify_realize_eh, id
    endcase
end


;+
;   Event handling method for Pro_Set_Value.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom_Pro_Set_Value, event
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Get the object reference and the NOTIFY_REALIZE method.
    widget_control, event.id, GET_UVALUE=oRef
    oRef -> GetProperty, HANDLER_PRO_SET_VALUE=pro_set_eh
    
    ;Forward the event to the proper procedure.
    case size(psvh, /TNAME) of
        'OBJREF': Call_Method, pro_set_eh.method, pro_set_eh.object, event
        'STRING': if pro_set_eh ne '' then Call_Procedure, pro_set_eh, event
    endcase
end


;+
;   The purpose of this method is to destroy the widget and, consequently, the object.
;-
pro MrWidgetAtom::Destroy
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Destroy the widget. This will trigger a Kill_Notify event. The Kill_Notify
    ;callback is, in turn, setup to destroy the object.
    if widget_info(self._id, /VALID_ID) then widget_control, self._id, /DESTROY
end


;+
;   Event handling function for Func_Get_Value.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;
; :Returns:
;       VALUE:          The value stored in the VALUE property of `EVENT`.ID
;-
function MrWidgetAtom::Func_Get_Value, event
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return, 0
    endif
    
    ;Get the value.
    widget_control, event.id, GET_VALUE=value
    
    ;Return the results.
    return, value
end


;+
;   Get object properties.
;-
pro MrWidgetAtom::GetProperty, $
 ID=id, $
 UVALUE = uvalue, $
 NO_COPY=no_copy, $
 
 ;Widget_Info Options
 ACTIVE=active, $
 ALL_CHILDREN=all_children, $
 CHILD=child, $
 DISPLAY=display, $
 FIND_BY_UNAME=find_by_uname, $
 FONT_NAME=font_name, $
 GEOMETRY=geometry, $
 MANAGED=managed, $
 MAP=map, $
 N_CHILDREN=n_children, $
 NAME=name, $
 PARENT=parent, $
 REALIZED=realized, $
 SENSITIVE=sensitive, $
 SIBLING=sibling, $
 STRING_SIZE=string_size, $
 SYSTEM_COLORS=system_colors, $
 TYPE=type, $
 UNITS=units, $
 UNAME=uname, $
 UPDATE=update, $
 VALID_ID=valid_id, $
 VERSION=version, $
 VISIBLE=visible, $
 
 ;Widget_Control Options
 TLB_GET_OFFSET=tlb_get_offset, $
 TLB_GET_SIZE=tlb_get_size, $
 
 ;Events On or Off?
 TRACKING_EVENTS = tracking_events, $
 KBRD_FOCUS_EVENTS=kbrd_focus_events, $
 
 ;Callback Pro/Func Event Handlers
 EVENT_PRO = event_pro, $
 EVENT_FUNC = event_func, $
 EVENT_HANDLER = event_handler, $
 FUNC_GET_VALUE = func_get_value, $
 KILL_NOTIFY = kill_notify, $
 NOTIFY_REALIZE = notify_realize, $
 PRO_GET_VALUE = pro_get_value, $
 
 ;Callback Object Handlers
 HANDLER_FUNC_GET_VALUE = func_get_value_handler, $
 HANDLER_KILL_NOTIFY = kill_notify_handler, $
 HANDLER_NOTIFY_REALIZE = notify_realize_handler, $
 HANDLER_PRO_SET_VALUE = pro_set_value_handler, $
 TRACKING_HANDLER=tracking_handler
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    valid_id = widget_info(self._id, /VALID_ID)
    if valid_id eq 0 then return

    if arg_present(id)     then id =  self._id
    if arg_present(uvalue) then begin
        uvalue = *self.uvalue
        if keyword_set(no_copy) then begin
            ptr_free, self.uvalue
            self.uvalue = ptr_new(/ALLOCATE_HEAP)
        endif
    endif
    
;---------------------------------------------------------------------
;Widget_Info & Widget_Control Options ////////////////////////////////
;---------------------------------------------------------------------
    ;Widget_Info
    if n_elements(active)         gt 0 then active        = widget_info(self._id, /ACTIVE)
    if n_elements(all_children)   gt 0 then all_children  = widget_info(self._id, /ALL_CHILDREN)
    if n_elements(child)          gt 0 then child         = widget_info(self._id, /CHILD)
    if n_elements(display)        gt 0 then display       = widget_info(self._id, /DISPLAY)
    if n_elements(find_by_uname)  gt 0 then find_by_uname = widget_info(self._id,  FIND_BY_UNAME=find_by_uname)
    if n_elements(font_name)      gt 0 then font_name     = widget_info(self._id, /FONT_NAME)
    if n_elements(geometry)       gt 0 then geometry      = widget_info(self._id, /GEOMETRY)
    if n_elements(managed)        gt 0 then managed       = widget_info(self._id, /MANAGED)
    if n_elements(n_children)     gt 0 then n_children    = widget_info(self._id, /N_CHILDREN)
    if n_elements(name)           gt 0 then name          = widget_info(self._id, /NAME)
    if n_elements(parent)         gt 0 then parent        = widget_info(self._id, /PARENT)
    if n_elements(realized)       gt 0 then realized      = widget_info(self._id, /REALIZED)
    if n_elements(sensitive)      gt 0 then sensitive     = widget_info(self._id, /SENSITIVE)
    if n_elements(sibling)        gt 0 then sibling       = widget_info(self._id, /SIBLING)
    if n_elements(string_size)    gt 0 then string_size   = widget_info(self._id,  STRING_SIZE=string_size)
    if n_elements(type)           gt 0 then type          = widget_info(self._id, /TYPE)
    if n_elements(units)          gt 0 then units         = widget_info(self._id, /UNITS)
    if n_elements(uname)          gt 0 then uname         = widget_info(self._id, /UNAME)
    if n_elements(update)         gt 0 then update        = widget_info(self._id, /UPDATE)
    if n_elements(version)        gt 0 then version       = widget_info(self._id, /VERSION)
    if n_elements(visible)        gt 0 then visible       = widget_info(self._id, /VISIBLE)
    
    ;Widget_Control
    if n_elements(tlb_get_offset) gt 0 then widget_control, self._id, TLB_GET_OFFSET=tlb_get_offset
    if n_elements(tlb_get_size)   gt 0 then widget_control, self._id, TLB_GET_SIZE=tlb_get_size
    
;---------------------------------------------------------------------
;Are Events On or Off? ///////////////////////////////////////////////
;---------------------------------------------------------------------
    if arg_present(tracking_events) then tracking_events =  widget_info(self._id, /TRACKING_EVENTS)
    
;---------------------------------------------------------------------
;Callback Func/Pro/Method/Object /////////////////////////////////////
;---------------------------------------------------------------------
    if arg_present(event_pro)       then event_pro       =  widget_info(self._id, /EVENT_PRO)
    if arg_present(event_func)      then event_func      =  widget_info(self._id, /EVENT_FUNC)
    if arg_present(func_get_value)  then func_get_value  =  widget_info(self._id, /FUNC_GET_VALUE)
    if arg_present(kill_notify)     then kill_notify     =  self._kill_notify
    if arg_present(notify_realize)  then notify_realize  =  self._notify_realize
    if arg_present(pro_get_value)   then pro_get_value   =  widget_info(self._id, /PRO_GET_VALUE)
    
    if arg_present(tracking_handler)       then tracking_handler       = *self._tracking_handler
    if arg_present(func_get_value_handler) then func_get_value_handler = *self._func_get_value
    if arg_present(kill_notify_handler)    then kill_notify_handler    = *self._kill_notify
    if arg_present(notify_realize_handler) then notify_realize_handler = *self._notify_realize
    if arg_present(pro_set_value_handler)  then pro_set_value_handler  = *self._pro_set_value
    
    if arg_present(event_handler) then begin
        if obj_valid(self._event_handler) $
            then event_handler = self._event_handler $
            else event_handler = obj_new()
    endif
end


;+
;   Event handling method for Kill_Notify. If CLEANUP was not provided when XManager was 
;   initiated, then XManager will forward cleanup detail to the procedure specified by
;   KILL_NOTIFY. If KILL_NOTIFY was not given when the object was created, then
;   Kill_Notify events will be directed here.
;
;   So, when the widget is destroyed, this is the fall-back cleanup method. The
;   default action is to destroy the object associated with the widget. If you do not
;   want this to happen, then you must supply your own CLEANUP or KILL_NOTIFY method.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom::Kill_Notify, id
   compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

    ;Destroy the object.
    obj_destroy, self
end


;+
;   Event handling method for Notify Realize.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom::Notify_Realize, event
    ;Nothing to do yet.
end


;+
;   Event handling method for Pro_Set_Value.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom::Pro_Set_Value, event
    ;Nothing to do yet.
end


;+
;   Event handling method for Tracking Events.
;
; :Params:
;       EVENT:              in, optional, type=structure
;                           An event structure returned by the windows manager.
;-
pro MrWidgetAtom::Tracking_Events, event
    ;Nothing to do yet.
end


;+
;
;-
pro MrWidgetAtom::Realize
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

   ; Check to see if the widget has been realized. If not, realize it.
   if (widget_info (self._id, /REALIZED) eq 0) then widget_control, self._id, /REALIZE
end


;+
;   Set object properties.
;-
pro MrWidgetAtom::SetProperty, $
 ;Widget_Control Options
 CLEAR_EVENTS=clear_events, $
 DEFAULT_FONTS=default_fonts, $
 HOURGLASS=hourglass, $
 MAP=map, $
 NO_COPY = no_copy, $
 REDRAW=redraw, $
 SENSITIVE=sensitive, $
 SCR_XSIZE=scr_xsize, $
 SCR_YSIZE=scr_ysize, $
 SHOW=show, $
 UNAME=uname, $
 UNITS=units, $
 UVALUE=uvalue, $
 UPDATE=update, $
 XOFFSET=xoffset, $
 XSIZE=xsize, $
 YOFFSET=yoffset, $
 YSIZE=ysize, $
 
 ;Turn Events On or Off
 TRACKING_EVENTS = tracking_events, $
 
 ;Callback Pro/Func/Method
 EVENT_HANDLER = event_handler, $
 FUNC_GET_VALUE = func_get_value, $
 KILL_NOTIFY = kill_notify, $
 NOTIFY_REALIZE = notify_realize, $
 PRO_SET_VALUE = pro_get_value, $
 TRACKING_HANDLER = tracking_handler
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif

;---------------------------------------------------------------------
;Widget Control Options //////////////////////////////////////////////
;---------------------------------------------------------------------
    
    if n_elements(uvalue) gt 0 then begin
        ptr_free, self.uvalue
        self.uvalue = ptr_new(uvalue, NO_COPY=no_copy)
    endif
    
    if n_elements(clear_events)  gt 0 then widget_control, self._id, CLEAR_EVENTS  = keyword_set(clear_events)
    if n_elements(default_fonts) gt 0 then widget_control,           DEFAULT_FONTS = default_fonts
    if n_elements(hourglass)     gt 0 then widget_control,           HOURGLASS     = keyword_set(hourglass)
    if n_elements(map)           gt 0 then widget_control, self._id, MAP           = keyword_set(map)
    if n_elements(redraw)        gt 0 then widget_control, self._id, REDRAW        = keyword_set(redraw)
    if n_elements(sensitive)     gt 0 then widget_control, self._id, SENSITIVE     = sensitive
    if n_elements(scr_xsize)     gt 0 then widget_control, self._id, SCR_XSIZE     = scr_xsize
    if n_elements(scr_ysize)     gt 0 then widget_control, self._id, SCR_YSIZE     = scr_ysize
    if n_elements(show)          gt 0 then widget_control, self._id, SHOW          = keyword_set(show)
    if n_elements(uname)         gt 0 then widget_control, self._id, SET_UNAME     = uname
    if n_elements(units)         gt 0 then widget_control, self._id, UNITS         = units
    if n_elements(update)        gt 0 then widget_control, self._id, UPDATE        = keyword_set(update)
    if n_elements(xoffset)       gt 0 then widget_control, self._id, XOFFSET       = xoffset
    if n_elements(xsize)         gt 0 then widget_control, self._id, XSIZE         = xsize
    if n_elements(yoffset)       gt 0 then widget_control, self._id, YOFFSET       = yoffset
    if n_elements(ysize)         gt 0 then widget_control, self._id, YSIZE         = ysize

;---------------------------------------------------------------------
;Turn Events On or Off ///////////////////////////////////////////////
;---------------------------------------------------------------------
    if n_elements(tracking_events) gt 0 then widget_control, self._id, TRACKING_EVENTS=keyword_set(tracking_events)

;---------------------------------------------------------------------
;Callback Func/Pro/Method/Object /////////////////////////////////////
;---------------------------------------------------------------------
    ;Set the event handler object
    if n_elements(event_handler) gt 0 then begin
        if obj_valid(event_handler) $
            then self._event_handler = event_handler $
            else self._event_handler = obj_new()
    endif
    
    ;FUNC_GET_VALUE
    if n_elements(func_get_value) gt 0 then begin
        case size(func_get_value, /TNAME) of
            'STRUCT': begin
                test = {MrEventHandler}
                struct_assign, func_get_value, test
                *self._func_get_value = test
                widget_control, self._id, FUNC_GET_VALUE='MrWidgetAtom_Func_Get_Value'
            endcase
            
            'STRING': begin
                widget_control, self_id, FUNC_GET_VALUE=func_get_value
                *self._func_get_value = func_get_value
            endcase
            
            else: message, 'FUNC_GET_VALUE must be a string or structure.'
        endcase
    endif
    
    ;KILL_NOTIFY
    if n_elements(kill_notify) gt 0 then begin
        case size(kill_notify, /TNAME) of
            'STRUCT': begin
                test = {MrEventHandler}
                struct_assign, kill_notify, test
                *self._kill_notify = test
                widget_control, self._id, KILL_NOTIFY='MrWidgetAtom_Kill_Notify'
            endcase
            
            'STRING': begin
                widget_control, self_id, KILL_NOTIFY=kill_notify
                *self._kill_notify = kill_notify
            endcase
            
            else: message, 'KILL_NOTIFY must be a string or structure.'
        endcase
    endif
    
    ;NOTIFY_REALIZE
    if n_elements(notify_realize) gt 0 then begin
        case size(notify_realize, /TNAME) of
            'STRUCT': begin
                test = {MrEventHandler}
                struct_assign, notify_realize, test
                *self._notify_realize = test
                widget_control, self._id, NOTIFY_REALIZE='MrWidgetAtom_Notify_Realize'
            endcase
            
            'STRING': begin
                widget_control, self_id, NOTIFY_REALIZE=notify_realize
                *self._notify_realize = notify_realize
            endcase
            
            else: message, 'NOTIFY_REALIZE must be a string or structure.'
        endcase
    endif
    
    ;PRO_SET_VALUE
    if n_elements(pro_set_value) gt 0 then begin
        case size(pro_set_value, /TNAME) of
            'STRUCT': begin
                test = {MrEventHandler}
                struct_assign, pro_set_value, test
                *self._pro_set_value = test
                widget_control, self._id, PRO_SET_VALUE='MrWidgetAtom_Pro_Set_Value'
            endcase
            
            'STRING': begin
                widget_control, self_id, PRO_SET_VALUE=pro_set_value
                *self._pro_set_value = pro_set_value
            endcase
            
            else: message, 'PRO_SET_VALUE must be a string or structure.'
        endcase
    endif
    
    ;TRACKING_HANDLER
    if n_elements(tracking_handler) gt 0 then begin
        case size(tracking_handler, /TNAME) of
            'STRUCT': begin
                test = {MrEventHandler}
                struct_assign, tracking_handler, test
                *self._tracking_handler = test
            endcase
            
            'STRING': self._tracking_handler = tracking_handler            
            else: message, 'TRACKING_HANDLER must be a string or structure.'
        endcase
    endif

end


;+
;   Set object properties.
;-
pro MrWidgetAtom::_Set_Event_Pro, event_pro
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Set the Callback Procedure
    widget_control, self._id, EVENT_PRO=event_pro
    self._event_pro = event_pro
    
    ;Make sure the event function is not being called
    if event_pro ne '' then self -> _Set_Event_Func, ''
end


;+
;   Set object properties.
;-
pro MrWidgetAtom::_Set_Event_Func, event_func
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;EVENT_FUNC
    widget_control, self._id, EVENT_FUNC=event_func
    self._event_func = event_func
    
    ;Make sure the event procedure is not being called
    if event_func ne '' then self -> _Set_Event_Pro, ''
end


;+
;   Clean up after the widget is destroyed.
;-
pro MrWidgetAtom::Cleanup
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return
    endif
    
    ;Free the user value
    ptr_free, self.uvalue
    
    ;Free event handlers (but do not destroy callback objects)
    ptr_free, self._func_get_value
    ptr_free, self._kill_notify
    ptr_free, self._notify_realize
    ptr_free, self._pro_set_value
    ptr_free, self._tracking_handler

    ;If the widget is still valid, destroy it.
    if widget_info(self._ID, /VALID_ID) then widget_control, self._id, /DESTROY
end


;+
;   This is the DRAWWIDGET object class initialization method
;
; :Params:
;
;       PARENT:         An object reference to a WIDGETATOM-subclassed object.
;                           This is the same as using the PARENT keyword.
;
; :Keywords:
;       EVENT_FUNC:             in, optional, type=string, default=''
;                               A string specifying the name of a function to be called
;                                   when events are generated.
;       EVENT_PRO:              in, optional, type=string, default=''
;                               A string specifying the name of a procedure to be called
;                                   when events are generated.
;       FUNC_GET_VALUE:         in, optional, type=string/structure, default=''
;                               A string specifying the name of a function to be called
;                                   when the value of the base is changed. Alternatively,
;                                   a structure of the form::
;                                       FUNC_GET_VALUE = {object: objRef, $
;                                                         method: 'Event_Handler'}
;                                   where "objRef" is a valid object reference and
;                                   "Event_Handler" is a string containing the name of a
;                                   function method to be used to handle events. In this
;                                   case, 'MrWidgetAtom_Func_Get_Value' will forward event
;                                   handling to the specified method.
;       KILL_NOTIFY:            in, optional, type=string/structure, default=''
;                               A string containing the name of a procedure to be called
;                                   when the widget dies. If a structure is provided
;                                   (see `FUNC_GET_VALUE`), then 'MrWidgetAtom_Kill_Notify'
;                                   will forward events to the given object method.
;       NOTIFY_REALIZE:         in, optional, type=string/structure, default=''
;                               A string containing the name of a procedure to be called
;                                   when the widget is realized. If a structure is provided
;                                   (see `FUNC_GET_VALUE`), then 'MrWidgetAtom_Notify_Realize'
;                                   will forward events to the given object method.
;       PRO_GET_VALUE:          in, optional, type=string, default=''
;                               A string specifying the name of a function to be called
;                                   when the value of the base is changed. If a structure
;                                   is provided (see `FUNC_GET_VALUE`), then
;                                   'MrWidgetAtom_Pro_Get_Value' will forward events to
;                                   the given object method.
;
;-
function MrWidgetAtom::init, parent, $
 NO_COPY = no_copy, $
 SENSITIVE = sensitive, $
 UNAME = uname, $
 UVALUE = uvalue, $
 ;Callbacks
 FUNCTION_CALLBACKS = function_callbacks, $
 FUNC_GET_VALUE = func_get_value, $
 KILL_NOTIFY = kill_notify, $
 NOTIFY_REALIZE = notify_realize, $
 PRO_SET_VALUE = pro_set_value, $
 TRACKING_EVENTS = tracking_events, $
 TRACKING_HANDLER = tracking_handler
    compile_opt strictarr
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = cgErrorMsg()
        return, 0
    endif
    
    
    if n_elements(sensitive) gt 0 then widget_control, self._id, SENSITIVE=keyword_set(sensitive)
    if n_elements(uname)     gt 0 then widget_control, self._id, SET_UNAME=uname
    
    ;Callback Func/Pro/Methods
    if n_elements(func_get_value)   eq 0 then func_get_value   = {object: self, method: 'Func_Get_Value'}
    if n_elements(kill_notify)      eq 0 then kill_notify      = {object: self, method: 'Kill_Notify'}
    if n_elements(notify_realize)   eq 0 then notify_realize   = {object: self, method: 'Notify_Realize'}
    if n_elements(pro_set_value)    eq 0 then pro_set_value    = {object: self, method: 'Pro_Set_Value'}
    if n_elements(tracking_handler) eq 0 then tracking_handler = {object: self, method: 'Tracking_Handler'}
    
    ;Allocate Heap
    self._func_get_value   = ptr_new(/ALLOCATE_HEAP)
    self._kill_notify      = ptr_new(/ALLOCATE_HEAP)
    self._notify_realize   = ptr_new(/ALLOCATE_HEAP)
    self._pro_set_value    = ptr_new(/ALLOCATE_HEAP)
    self._tracking_handler = ptr_new(/ALLOCATE_HEAP)
    
    ;Objects
    self._event_handler = obj_new()
    
;---------------------------------------------------------------------
;Set Object Properties ///////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;Set the event callback routine.
    if keyword_set(function_callbacks) $
        then self -> _Set_Event_Func, 'MrWidgetAtom_Event_Func' $
        else self -> _Set_Event_Pro,  'MrWidgetAtom_Event_Pro'
    
    ;Set Object Properties
    self -> SetProperty, UNAME=uname, $
                         UVALUE=uvalue, $
                         SENSITIVE=sensitive, $
                         ;Callbacks
                         EVENT_HANDLER=event_handler, $
                         KILL_NOTIFY=kill_notify, $
                         NOTIFY_REALIZE=notify_realize, $
                         PRO_SET_VALUE=pro_set_value, $
                         TRACKING_EVENTS=tracking_events, $
                         TRACKING_HANDLER=tracking_handler
    return, 1
end



;+
;   The class definition statement.
;
; :Params:
;       CLASS:          out, optional, type=structure
;                       The class definition structure.
;
; :Fields:
;       _ID:                    Widget ID of the top level base
;       _EVENT_FUNC:            Event handling function for base widget events.
;       _EVENT_PRO:             Event handling procedure for widget base events.
;       _FUNC_GET_VALUE:        Object and function method to handle get value events.
;       _PRO_SET_VALUE:         Object and procedure method to handle get value events.
;       UVALUE:                 The user value of the widget object.
;-
pro MrWidgetAtom__define, class
    
    class = { MrWidgetAtom, $
              _id:               0L, $
              _event_handler:    obj_new(), $
              _event_func:       '', $
              _event_pro:        '', $
              _func_get_value:   ptr_new(), $
              _kill_notify:      ptr_new(), $
              _notify_realize:   ptr_new(), $
              _pro_set_value:    ptr_new(), $
              _tracking_handler: ptr_new(), $
              uvalue:            ptr_new() $
            }
end