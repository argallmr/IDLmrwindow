; docformat = 'rst'
;
; NAME:
;       MrPlotWindow__Define
;
;*****************************************************************************************
;   Copyright (c) 2013, Matthew Argall                                                   ;
;   All rights reserved.                                                                 ;
;                                                                                        ;
;   Redistribution and use in source and binary forms, with or without modification,     ;
;   are permitted provided that the following conditions are met:                        ;
;                                                                                        ;
;       * Redistributions of source code must retain the above copyright notice,         ;
;         this list of conditions and the following disclaimer.                          ;
;       * Redistributions in binary form must reproduce the above copyright notice,      ;
;         this list of conditions and the following disclaimer in the documentation      ;
;         and/or other materials provided with the distribution.                         ;
;       * Neither the name of the <ORGANIZATION> nor the names of its contributors may   ;
;         be used to endorse or promote products derived from this software without      ;
;         specific prior written permission.                                             ;
;                                                                                        ;
;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY  ;
;   EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ;
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  ;
;   SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,       ;
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED ;
;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   ;
;   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     ;
;   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN   ;
;   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  ;
;   DAMAGE.                                                                              ;
;*****************************************************************************************
;
;+
;   The purpose of this method is to manage the creation, addition, and removal of plots.
;   Plots, if not given a position, will be fit into a 2D plotting grid that automatically
;   determines plot locations when additional plots are added or removed.
;
;   If a plot object 
;
; :Author:
;   Matthew Argall::
;       University of New Hampshire
;       Morse Hall, Room 113
;       8 College Rd.
;       Durham, NH, 03824
;       matthew.argall@wildcats.unh.edu
;
; :Copyright:
;       Matthew Argall 2013, All rights reserved
;
; :History:
;	Modification History::
;       05/20/2013  -   Written by Matthew Argall
;       05/27/2013  -   The Plot method was not interfacing with the AddPlots and
;                           SetPositions properly. Fixed. - MRA
;       05/30/2013  -   Moved the Clear, Remove, and Replace from AddPlots into their
;                           own methods. Added the DESTROY keyword to all of them. Added
;                           the allObjects property to the class so that line plots,
;                           images, contours, etc. could all be added into a master list
;                           that matches that of MrPlotLayout.Plot_Positions. This means
;                           that objects have to be added/removed/replaced in allObjects
;                           as well as in the superclass properties MrAbstractPlot.plotObjects,
;                           MrAbstractImage.imageObjects, etc. The reason for keeping
;                           each of these lists is to be able to distinguish a plot
;                           object from an image object from a ... while still allowing
;                           any object class to be added.
;       05/31/2013  -   Added the Add method to generalize the object-adding process.
;                           Add will add any object to the master list. - MRA
;       06/19/2013  -   Fixed typos and several minor bugs. - MRA
;       07/03/2013  -   Positions were not determined properly when external plots are
;                           added. Fixed. - MRA
;       07/03/2013  -   Positions generated by the Add method are not applied to the
;                           appropriate object correctly. - MRA
;       07/09/2013  -   Positions or locations can be passed to calcColorBarPosition. - MRA
;       08/16/2013  -   Inherit MrIDL_Container and MrCreateGraphic. Removed the Plot
;                           and Image methods. No longer inherit MrAbstract* methods.
;                           The Add method now forwards actions to other methods instead
;                           of being a secondary method. Removed the allObjects property. 
;                           Removed the Add* methods for individual graphic types. - MRA
;       08/22/2013  -   Add, ShiftPlots, ApplyPositions, WhatAmI, and Config methods are
;                           working properly after remodelling the MrPlotLayout class.
;                           Added the Plot, Image, and Contour methods. The Remove
;                           method now works. - MRA
;                                   
;-
;*****************************************************************************************
;+
;   Add an object to the master list. This method SHOULD NOT be used directly. Instead,
;   use AddPlots, AddImages, etc.
;
; :Params:
;       THEOBJECTS:            in, optional, type=object/obj_arr(N)
;                               The plot object(s) to add to the display.
;
;   :Keywords:
;       INDEX:                  in, optional, type=int/intarr, default=[last]
;                               The index location(s) into the container at which to add
;                                   the object(s). The default is to put the objects at
;                                   the end of the container.
;       POSITION:               out, optional, type=fltarr(4\,N)
;       LOCATION:               out, optional, type=intarr(2\,N)
;-
pro MrPlotManager::Add, theObjects, $
INDEX = index, $
LOCATION = location, $
POSITION = position
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    ;How many objects were given?
    nObj = n_elements(theObjects)
    nIndex = n_elements(index)
    layout_init = self.layout
    
;---------------------------------------------------------------------
;Add to Master List //////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;If nothing was given to add, then return
    if nObj eq 0 then return
        
    ;Allocate memory for the positions and locations.
    location = intarr(2, nObj)
    position = fltarr(4, nObj)
    
    ;Make sure a location and position is defined for each plot
    for i = 0, nObj - 1 do begin
        skip = 0
        if nIndex gt 0 then thisIndex = index[i]
        ImA = self -> WhatAmI(theObjects[i])

    ;---------------------------------------------------------------------
    ;Unknown Objects /////////////////////////////////////////////////////
    ;---------------------------------------------------------------------
        if ImA eq '' then begin
            print, FORMAT='(%"MrPlotManager::Add: Object \"%s\" at index %i is not recognized. Cannot add.")', $
                   typename(theObjects[i]), i
            continue
        endif
            
    ;---------------------------------------------------------------------
    ;"Annotation" Objects ////////////////////////////////////////////////
    ;---------------------------------------------------------------------
        isData = isMember((*self.gTypes).ImAData, ImA) 
        if isData eq 0 then begin
            self -> MrIDL_Container::Add, theObjects[i], INDEX=thisIndex
            continue
        endif
        
    ;---------------------------------------------------------------------
    ;"Data" Objects //////////////////////////////////////////////////////
    ;---------------------------------------------------------------------
        
        ;Get the position and layout of the object.
        theObjects[i] -> GetProperty, POSITION=pos, LAYOUT=layout
        
        ;Record the initial position for comparison.
        if n_elements(pos) eq 0 $
            then pos_init = !Null $
            else pos_init = pos
        
        ;Get the "location" part of the layout.
        case n_elements(layout) of
            0: ;Do Nothing
            3: loc = layout[2]
            4: loc = layout[2:3]
            else: begin
                print, FOMRAT='(%"Cannot add object %s at index %i". Improper layout)', $
                       typename(theObjects[i]), i
                print, 'Layout = ', layout
                skip = 1
            endelse
        endcase
        if skip then continue

        ;Set the location and position of the new plot.
        ;   If LOC is undefined, it will be returned either as an auto-updating location
        ;       (if POS is undefined) or as a fixed location (if POS is defined). If LOC
        ;       is defined and different plot already occupies that location, existing
        ;       plots will be shifted out of the way to make room.
        ;
        ;   If POS is undefined, then Auto-Updating position and location will be returned.
        ;       If defined and LOC is undefined, 
        self -> AddToLayout, loc, pos
        
        ;Set the location and position as object properties

        if loc[0] gt 0 then theObjects[i] -> SetProperty, LAYOUT=[self.layout[0:1], loc]
        theObjects[i] -> SetProperty, POSITION=pos
        
        ;Store the location and position if they were created.
        location[*,i] = temporary(loc)
        position[*,i] = temporary(pos)

        ;Add the object to the container.
        self -> MrIDL_Container::Add, theObjects[i], INDEX=thisIndex
    endfor
    
;---------------------------------------------------------------------
;Apply New Positions /////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;If the layout has changed, we need to apply the new positions to all plots.
    if array_equal(layout_init, self.layout) eq 0 $
        then self -> ApplyPositions
end


;+
;   The purpose of this method is to apply the positions of a new layout to all plots
;   within the layout.
;-
pro MrPlotManager::ApplyPositions
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
        
;---------------------------------------------------------------------
;Reposition Plots ////////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;Get all of the data objects
    dataObjs = self -> Get(/ALL, ISA=(*self.gTypes).data, COUNT=nData)
    
    ;Step through each object
    for i = 0, nData - 1 do begin
    
        ;Check to see that it has a LAYOUT specified
        dataObjs[i] -> GetProperty, LAYOUT=layout
        nLayout = n_elements(layout)
        if nLayout eq 0 then continue
        
        ;Get the [col,row] location of the plot
        case nLayout of
            3: thisColRow = self -> ConvertLocation(layout[2], /PLOT_INDEX, /TO_COLROW)
            4: thisColRow = layout[2:3]
            else: message, 'Layout has incorrect format.'
        endcase

        ;Update the positions of each plot.
        position = (*self.layout_positions)[*, thisColRow[0]-1, thisColRow[1]-1]
        dataObjs[i] -> SetProperty, POSITION=position
    endfor
end


;+
;   Create a MrContour object. It can be drawn to the display and/or
;   added to the container
;
; :Keywords:
;       ADD:                in, optional, type=boolean, default=0
;                           Add the coutour object to the container. This assumes that the
;                               IDL_Container class or MrIDL_Container class is also a
;                               subclass.
;       DRAW:               in, optional, type=boolean, default=0
;                           Call the Draw method after adding the image to the list.
;       LAYOUT:             in, optional, type=intarr
;                           A vector in the form [layout, location], where "layout" is
;                               a 2-element vector specifying the number of rows and
;                               columns, and "location" is a 2-element vector specifying
;                               the [col,row] location within "layout" at which `THEPLOT`
;                               should be placed.
;       POSITION:           in, optional, type=boolean
;                           The standard 4-element position vector accepted by PLOT. If
;                               not given and the `ADD` is set, a position will be chosen
;                               from the available layout positions.
;       _REF_EXTRA:         in, optional, type=structure
;                           Any keyword accepted by MrImagePlot__define.
;
; :Returns:
;       THECONTOUR:         out, required, type=object
;                           An object reference to the contour.
;   
;-
function MrPlotManager::Contour, data, x, y, $
ADD = add, $
DRAW = draw, $
LAYOUT = layout, $
POSITION = position, $
_REF_EXTRA = extra
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, obj_new()
    endif
    
    SetDefaultValue, add, 1, /BOOLEAN
    SetDefaultvalue, draw, 1, /BOOLEAN

;---------------------------------------------------------------------
;Fit within Current Layout? //////////////////////////////////////////
;---------------------------------------------------------------------
    ;Make sure the plot fits within the layout
    if add eq 1 then begin
        ;Was a [col,row] location provided?
        case n_elements(layout) of
            0: ;Do nothing
            3: location = self -> ConvertLocation(layout[2], /PLOT_INDEX, /TO_COLROW)
            4: location = layout[2:3]
            else: Message, 'Invalid layout. Cannot Plot.'
        endcase
    
        ;Was a position provided?
        if n_elements(position) eq 0 then fixed = 0 else fixed = 1

        ;Get a location and/or position if none were provided.
        self -> GetPositions, location, POSITION=position, LAYOUT=layout, UPDATE_LAYOUT=0
        if location[0] gt 0 $
            then layout = ptr_new([layout, location]) $
            else layout = ptr_new(/ALLOCATE_HEAP)
        
    endif else layout = ptr_new(/ALLOCATE_HEAP)
    
;---------------------------------------------------------------------
;Create the Image ////////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;Create the color bar
    theContour = obj_new('MrContour', data, x, y, _STRICT_EXTRA=extra)
    
    ;Add the image
    if keyword_set(add) then self -> Add, theContour
    
    ;Draw    
    if keyword_set(draw) then self -> Draw
    
    return, theContour
end


;+
;   Create a MrImagePlot object. It can be drawn to the display and/or
;   added to the container
;
; :Keywords:
;       ADD:                in, optional, type=boolean, default=0
;                           Add the plot object to the container. This assumes that the
;                               IDL_Container class or MrIDL_Container class is also a
;                               subclass.
;       DRAW:               in, optional, type=boolean, default=0
;                           Call the Draw method after adding the image to the list.
;       LAYOUT:             in, optional, type=intarr
;                           A vector in the form [layout, location], where "layout" is
;                               a 2-element vector specifying the number of rows and
;                               columns, and "location" is a 2-element vector specifying
;                               the [col,row] location within "layout" at which `THEPLOT`
;                               should be placed.
;       POSITION:           in, optional, type=boolean
;                           The standard 4-element position vector accepted by PLOT. If
;                               not given and the `ADD` is set, a position will be chosen
;                               from the available layout positions.
;       _REF_EXTRA:         in, optional, type=structure
;                           Any keyword accepted by MrImagePlot__define.
;
; :Returns:
;       THEIMAGE:           out, required, type=object
;                           An object reference to the image.
;   
;-
function MrPlotManager::Image, image, x, y, $
ADD = add, $
DRAW = draw, $
LAYOUT = layout, $
POSITION = position, $
_REF_EXTRA = extra
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, obj_new()
    endif
    
    SetDefaultValue, add, 1, /BOOLEAN
    SetDefaultvalue, draw, 1, /BOOLEAN

;---------------------------------------------------------------------
;Fit within Current Layout? //////////////////////////////////////////
;---------------------------------------------------------------------
    ;Make sure the plot fits within the layout
    if add eq 1 then begin
        ;Was a [col,row] location provided?
        case n_elements(layout) of
            0: ;Do nothing
            3: location = self -> ConvertLocation(layout[2], /PLOT_INDEX, /TO_COLROW)
            4: location = layout[2:3]
            else: Message, 'Invalid layout. Cannot Plot.'
        endcase
    
        ;Was a position provided?
        if n_elements(position) eq 0 then fixed = 0 else fixed = 1

        ;Get a location and/or position if none were provided.
        self -> GetPositions, location, POSITION=position, LAYOUT=layout, UPDATE_LAYOUT=0
        if location[0] gt 0 $
            then layout = ptr_new([layout, location]) $
            else layout = ptr_new(/ALLOCATE_HEAP)
        
    endif else layout = ptr_new(/ALLOCATE_HEAP)
    
;---------------------------------------------------------------------
;Create the Image ////////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;Create the color bar
    theImage = obj_new('MrImagePlot', image, x, y, _STRICT_EXTRA=extra)
    
    ;Add the image
    if keyword_set(add) then self -> Add, theImage
    
    ;Draw    
    if keyword_set(draw) then self -> Draw
    
    return, theImage
end


;+
;   Create a MrPlotObject object. If it is being added to the current window's container,
;   make sure it fits within the new layout. cgPlot automatically picks a position, so
;   we need to pre-empt that.
;
; :Keywords:
;       ADD:                in, optional, type=boolean, default=0
;                           Add the plot object to the container. This assumes that the
;                               IDL_Container class or MrIDL_Container class is also a
;                               subclass.
;       DRAW:               in, optional, type=boolean, default=0
;                           Call the Draw method after adding the plot to the list.
;       LAYOUT:             in, optional, type=intarr
;                           A vector in the form [layout, location], where "layout" is
;                               a 2-element vector specifying the number of rows and
;                               columns, and "location" is a 2-element vector specifying
;                               the [col,row] location within "layout" at which `THEPLOT`
;                               should be placed.
;       POSITION:           in, optional, type=boolean
;                           The standard 4-element position vector accepted by PLOT. If
;                               not given and the `ADD` is set, a position will be chosen
;                               from the available layout positions.
;       _REF_EXTRA:         in, optional, type=structure
;                           Any keyword accepted by MrPlotObject__define.
;
; :Returns:
;       THEPLOT:            out, required, type=object
;                           An object reference to the plot.
;   
;-
function MrPlotManager::Plot, x, y, $
ADD = add, $
DRAW = draw, $
POSITION = position, $
LAYOUT = layout, $
_REF_EXTRA = extra
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        if ptr_valid(layout) then ptr_free, layout
        void = error_message()
        return, obj_new()
    endif
    
    SetDefaultValue, add, 1, /BOOLEAN
    SetDefaultvalue, draw, 1, /BOOLEAN

;---------------------------------------------------------------------
;Fit within Current Layout? //////////////////////////////////////////
;---------------------------------------------------------------------
    ;Make sure the plot fits within the layout
    if add eq 1 then begin
        ;Was a [col,row] location provided?
        case n_elements(layout) of
            0: ;Do nothing
            3: location = self -> ConvertLocation(layout[2], /PLOT_INDEX, /TO_COLROW)
            4: location = layout[2:3]
            else: Message, 'Invalid layout. Cannot Plot.'
        endcase
    
        ;Was a position provided?
        if n_elements(position) eq 0 then fixed = 0 else fixed = 1

        ;Get a location and/or position if none were provided.
        self -> GetPositions, location, POSITION=position, LAYOUT=layout, UPDATE_LAYOUT=0
        if location[0] gt 0 $
            then layout = ptr_new([layout, location]) $
            else layout = ptr_new(/ALLOCATE_HEAP)
        
    endif else layout = ptr_new(/ALLOCATE_HEAP)
    
;---------------------------------------------------------------------
;Create the Plot /////////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;Create the plot
    thePlot = obj_new('MrPlotObject', $
                      x, y, $
                      POSITION=position, $
                      LAYOUT=*layout, $
                      _EXTRA=extra)
    ptr_free, layout

    ;Add the plot to the container?
    if keyword_set(add) then self -> Add, thePlot
    
    ;Draw the plot?
    if keyword_set(draw) then self -> Draw
    
    return, thePlot
end


;+
;   Remove a Plot or Image object from the list of objects being displayed.
;
; :Params:
;       LOCATION:               in, optional, type=intarr(2\,N), default=[1\,1]
;                               The [col, row] location of the plot to replace
;
;   :Keywords:
;       ADJUST_LAYOUT:          in, optional, private, type=Boolean, default=0
;                               Sometimes holes are created in the plot layout when a
;                                   plots are added or removed. Set this keyword to remove
;                                   holes in the plot layout.
;       DESTROY:                in, optional, type=boolean, default=1
;                               Destroy the objects being replaced.
;       DRAW:                   in, optional, type=boolean, default=0
;                               Call the Draw method after adding the legends to the list.
;       INDEX                   in, optional, type=boolean, default=0
;                               If set, then `LOCATION` is actually the index within at
;                                   which the plot is stored.
;       PLOT_INDEX:             in, optional, type=int, default=0
;                               If set, then `LOCATION` is actually the 1D plot index of
;                                   the plot. The upper-left-most plot has a plot index of
;                                   1, and the plot index increases as you go down the
;                                   column, then across the row.
;-
pro MrPlotManager::Remove, Child_object, $
ALL = all, $
DESTROY = destroy, $
DRAW = draw, $
INDEX = index, $
TYPE = type
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    ;Defaults
    SetDefaultValue, draw, 0, /BOOLEAN
    SetDefaultValue, destroy, 1, /BOOLEAN
        
;---------------------------------------------------------------------
;Remove All //////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    if keyword_set(all) then begin
        self -> MrIDL_Container::Remove, /ALL, DESTROY=destroy
        self -> ClearLayout
        return
    endif
        
;---------------------------------------------------------------------
;Remove Indices //////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    if n_elements(index) gt 0 then begin
        ;Get the objects being removed.
        removeThese = self -> Get(POSITION=index, COUNT=nRemove)
        
        ;Step through all of the objects.
        for i = 0, nRemove - 1 do begin
            ;Get their position and layout.
            removeThese[i] -> GetProperty, LAYOUT=layout, POSITION=position
            
            ;Get their [col, row] location.
            case n_elements(layout) of
                0: thisLoc = self -> FindFixedLocation(position)
                3: thisLoc = self -> ConvertLocation(layout[2:3], layout, /PLOT_INDEX, /TO_COLROW)
                4: thisLoc = layout[2:3]
                else: message, 'Layout has incorrect format. Cannot be removed.'
            endcase
            
            ;Remove from the container and from the layout.
            self -> MrIDL_Container::Remove, removeThese[i], DESTROY=destroy
            self -> RemoveFromLayout, thisLoc
        endfor
    endif
        
;---------------------------------------------------------------------
;Remove Type /////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    if n_elements(type) gt 0 then begin
        ;Get the objects being removed.
        removeThese = self -> Get(ISA=type, COUNT=nRemove)
        
        ;Step through all of the objects.
        for i = 0, nRemove - 1 do begin
            ;Get their position and layout.
            removeThese[i] -> GetProperty, LAYOUT=layout, POSITION=position
            
            ;Get their [col, row] location.
            case n_elements(layout) of
                0: thisLoc = self -> FindFixedLocation(position)
                3: thisLoc = self -> ConvertLocation(layout[2:3], layout, /PLOT_INDEX, /TO_COLROW)
                4: thisLoc = layout[2:3]
                else: message, 'Layout has incorrect format. Cannot be removed.'
            endcase
            
            ;Remove from the container and from the layout.
            self -> MrIDL_Container::Remove, removeThese[i], DESTROY=destroy
            self -> RemoveFromLayout, thisLoc
        endfor
    endif
        
;---------------------------------------------------------------------
;Remove Child_Objects ////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    if n_elements(Child_Object) gt 0 then begin
        nRemove = n_elements(Child_Object)
        
        ;Step through all of the objects.
        for i = 0, nRemove - 1 do begin
            ;Get their position and layout.
            Child_Object[i] -> GetProperty, LAYOUT=layout, POSITION=position
            
            ;Get their [col, row] location.
            case n_elements(layout) of
                0: thisLoc = self -> FindFixedLocation(position)
                3: thisLoc = self -> ConvertLocation(layout[2:3], layout, /PLOT_INDEX, /TO_COLROW)
                4: thisLoc = layout[2:3]
                else: message, 'Layout has incorrect format. Cannot be removed.'
            endcase
            
            ;Remove from the container and from the layout.
            self -> MrIDL_Container::Remove, Child_Object[i], DESTROY=destroy
            self -> RemoveFromLayout, thisLoc
        endfor
    endif
    
;---------------------------------------------------------------------
;Draw ////////////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    ;Draw?
    if keyword_set(draw) then self -> Draw
 
 end


;+
;   Shift all plots located at and after LOCATION up one index value.
;
; :Params:
;
;       LOCATION:           in, required, type=lonarr(2)
;                           The 1-based plot location [col, row] at which to begin 
;                               shifting plots.
;-
pro MrPlotManager::ShiftPlots, location
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    layout_init = self.layout
    
;---------------------------------------------------------------------
;Start and Stop Shift ////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;Convert LOCATION to a plot index
    pStartShift = self -> ConvertLocation(location, /TO_PLOT_INDEX)
    
    ;Get the available list indices
    iFree = self -> GetListIndexAvailability(NFREE=nFree)
    if nFree gt 0 then pFree = self -> ConvertLocation(iFree, /LIST_INDEX, /TO_PLOT_INDEX)
    
    ;Which interval is being shifted? If a new row needs to be added,
    ;re-calculate the starting plot index within the new layout.
    if nFree eq 0 || max(pFree gt pStartShift) eq 0 then begin
        layout = self.layout + [0,1]
        pStartShift = self -> ConvertLocation(location, layout, /TO_PLOT_INDEX)
        pStopShift = self -> ConvertLocation([1, layout[1]], layout, /TO_PLOT_INDEX)
    endif else begin
        layout = self.layout
        pStopShift = min(where((pFree gt pStartShift) eq 1))
    endelse
    
;---------------------------------------------------------------------
;Superclass //////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;Shift the layout so that the layout_positions are up-to-date.
    self -> MrPlotLayout::ShiftPlots, location
    
;---------------------------------------------------------------------
;Shift Plots /////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;Get all of the relevant objects
    theseObj = self -> Get(/ALL, ISA=(*self.gTypes).data, COUNT=nObj)
    
    ;Start shifting them
    for i = 0, nObj - 1 do begin
        theseObj[i] -> GetProperty, LAYOUT=objLayout
        nLayout = n_elements(objLayout)
        if nLayout eq 0 then continue
        
        case nLayout of
            3: thisPIndex = objLayout[2]
            4: thisPIndex = self -> ConvertLocation(objLayout[2:3], layout, /TO_PLOT_INDEX)
            else: message, 'Layout has incorrect format. Cannot be shifted.'
        endcase
        
        if thisPIndex lt pStartShift then continue
        if thisPIndex ge pStopShift then break
        
        ;If we make it to here, shift the plot
        thisPIndex += 1
        newLocation = self -> ConvertLocation(thisPIndex, layout, /PLOT_INDEX, /TO_COLROW)
        newPosition = (*self.layout_positions)[*, newLocation[0]-1, newLocation[1]-1]
        theseObj[i] -> SetProperty, LAYOUT=[layout, newLocation], POSITION=newPosition
    endfor
end


;+
;   Determine which type of object was given.
;
; :Params:
;       OBJREF:             in, required, type=Object
;                           An object reference whose "type" is to be determined. Will
;                               tell you if the object is a Plot or Image.
;
; :Returns:
;       IMA:                out, required, type=string
;                           The type of object that was passed. This is determined by
;                               scanning all of the different lists of objects to find
;                               a match. If no match is found, the empty string is
;                               returned.
;-
function MrPlotManager::WhatAmI, objRef
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, ''
    endif
    
    ;What type of object is it?
    className = typename(objRef)
    case className of
        'MRPLOTOBJECT':  ImA = 'PLOT'
        'MRIMAGEOBJECT': ImA = 'IMAGE'
        'MRCONTOUR':     ImA = 'CONTOUR'
        'WECOLORBAR':    ImA = 'COLORBAR'
        'WETEXT':        ImA = 'TEXT'
        'WEARROW':       ImA = 'ARROW'
        'WEOVERPLOT':    ImA = 'OVERPLOT'
        'WELEGENDITEM':  ImA = 'LEGEND'
        'WEAXIS':        ImA = 'AXIS'
        else:            ImA = ''
    endcase
    
    return, ImA
end


;+
;   The purpose of this method is to create a structure of supported classes for each
;   graphics type.
;-
pro MrPlotManager::Config
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    ;Class names of the supported graphics types
    types = { plot: ['PLOT', 'MRPLOTOBJECT'], $
              image: ['IMAGE', 'MRIMAGEOBJECT'], $
              contour: ['CONTOUR', 'MRCONTOUR'], $
              colorbar: ['WECOLORBAR'], $
              axis: ['WEAXIS'], $
              legend: ['WELEGENDITEM'], $
              arrow: ['WEARROW'], $
              text: ['WETEXT'], $
              overplot: ['WEOVERPLOT'], $
              ImAData: ['PLOT', 'IMAGE', 'CONTOUR'], $     ;TO BE USED WITH ::WHATAMI
              data: ['PLOT', 'MRPLOTOBJECT', 'IMAGE', 'MRIMAGEOBJECT', 'CONTOUR', 'MRCONTOUR'], $
              annotate: ['WECOLORBAR', 'WEAXIS', 'WELEGENDITEM', 'WEARROW', 'WETEXT'] $
            }
    
    ;Store them as a class property
    self.gTypes = ptr_new(types, /NO_COPY)

end


;+
;   Clean up after the object is destroy
;-
pro MrPlotManager::cleanup
    compile_opt idl2
    
    ;Destroy all weLegendItem objects
    self -> MrPlotLayout::Cleanup
    self -> MrIDL_Container::Cleanup
    self -> MrCreateGraphic::Cleanup
    
    ;Free pointers
    ptr_free, self.gTypes
end


;+
;   The initialization method.
;
; :Keywords:
;       _REF_EXTRA:                 in, optional, type=structure
;                                   Any keyword accepted by MrPlotLayout__define is also
;                                       accepted for keyword inheritance.
;-
function MrPlotManager::init, $
_REF_EXTRA = extra
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, 0
    endif

    ;Setup the plot window
    if self -> MrPlotLayout::init(_STRICT_EXTRA=extra) eq 0 then return, 0
    
    ;Configure the object
    self -> config
    
    return, 1
end


;+
;   Object class definition
;
; :Params:
;       CLASS:          out, optional, type=structure
;                       The class definition structure.
;-
pro MrPlotManager__define, class
    compile_opt idl2
    
    define = { MrPlotManager, $
               inherits MrIDL_Container, $      ;An object container
               inherits MrCreateGraphic, $      ;Plots, Images, Colorbars, Text, Arrows, etc.
               inherits MrPlotLayout, $         ;Manage plot layout
               gTypes: ptr_new() $              ;Supported graphics types.
             }
end