; docformat = 'rst'
;
; NAME:
;       MrPlotWindow__Define
;
;*****************************************************************************************
;   Copyright (c) 2013, Matthew Argall                                                   ;
;   All rights reserved.                                                                 ;
;                                                                                        ;
;   Redistribution and use in source and binary forms, with or without modification,     ;
;   are permitted provided that the following conditions are met:                        ;
;                                                                                        ;
;       * Redistributions of source code must retain the above copyright notice,         ;
;         this list of conditions and the following disclaimer.                          ;
;       * Redistributions in binary form must reproduce the above copyright notice,      ;
;         this list of conditions and the following disclaimer in the documentation      ;
;         and/or other materials provided with the distribution.                         ;
;       * Neither the name of the <ORGANIZATION> nor the names of its contributors may   ;
;         be used to endorse or promote products derived from this software without      ;
;         specific prior written permission.                                             ;
;                                                                                        ;
;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY  ;
;   EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ;
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  ;
;   SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,       ;
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED ;
;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   ;
;   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     ;
;   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN   ;
;   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  ;
;   DAMAGE.                                                                              ;
;*****************************************************************************************
;
;+
;   The purpose of this method is to manage the creation, addition, and removal of plots.
;   Plots, if not given a position, will be fit into a 2D plotting grid that automatically
;   determines plot locations when additional plots are added or removed.
;
;   If a plot object 
;
; :Author:
;   Matthew Argall::
;       University of New Hampshire
;       Morse Hall, Room 113
;       8 College Rd.
;       Durham, NH, 03824
;       matthew.argall@wildcats.unh.edu
;
; :Copyright:
;       Matthew Argall 2013, All rights reserved
;
; :History:
;	Modification History::
;       05/20/2013  -   Written by Matthew Argall
;       05/27/2013  -   The Plot method was not interfacing with the AddPlots and
;                           SetPositions properly. Fixed. - MRA
;       05/30/2013  -   Moved the Clear, Remove, and Replace from AddPlots into their
;                           own methods. Added the DESTROY keyword to all of them. Added
;                           the allObjects property to the class so that line plots,
;                           images, contours, etc. could all be added into a master list
;                           that matches that of MrPlotLayout.Plot_Positions. This means
;                           that objects have to be added/removed/replaced in allObjects
;                           as well as in the superclass properties MrAbstractPlot.plotObjects,
;                           MrAbstractImage.imageObjects, etc. The reason for keeping
;                           each of these lists is to be able to distinguish a plot
;                           object from an image object from a ... while still allowing
;                           any object class to be added.
;       05/31/2013  -   Added the Add method to generalize the object-adding process.
;                           Add will add any object to the master list. - MRA
;       06/19/2013  -   Fixed typos and several minor bugs. - MRA
;       07/03/2013  -   Positions were not determined properly when external plots are
;                           added. Fixed. - MRA
;       07/03/2013  -   Positions generated by the Add method are not applied to the
;                           appropriate object correctly. - MRA
;       07/09/2013  -   Positions or locations can be passed to calcColorBarPosition. - MRA
;       08/16/2013  -   Inherit MrIDL_Container and MrCreateGraphic. Removed the Plot
;                           and Image methods. No longer inherit MrAbstract* methods.
;                           The Add method now forwards actions to other methods instead
;                           of being a secondary method. Removed the allObjects property. 
;                           Removed the Add* methods for individual graphic types. - MRA
;                                   
;-
;*****************************************************************************************
;+
;   Add an object to the master list. This method SHOULD NOT be used directly. Instead,
;   use AddPlots, AddImages, etc.
;
; :Params:
;       THEOBJECTS:            in, optional, type=object/obj_arr(N)
;                               The plot object(s) to add to the display.
;
;   :Keywords:
;       INDEX:                  in, optional, type=int/intarr, default=[last]
;                               The index location(s) into the container at which to add
;                                   the object(s). The default is to put the objects at
;                                   the end of the container.
;       POSITION:               out, optional, type=fltarr(4\,N)
;       LOCATION:               out, optional, type=intarr(2\,N)
;-
pro MrPlotManager::Add, theObjects, $
INDEX = index, $
LOCATION = location, $
POSITION = position
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    ;How many objects were given?
    nObj = n_elements(theObjects)
    nIndex = n_elements(index)
    
;---------------------------------------------------------------------
;Add to Master List //////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;If nothing was given to add, then return
    if nObj eq 0 then return
        
    ;Allocate memory for the positions and locations.
    location = intarr(2, nObj)
    position = fltarr(4, nObj)
    
    ;Make sure a location and position is defined for each plot
    for i = 0, nObj - 1 do begin
        skip = 0
        if nIndex gt 0 then thisIndex = index[i]
        ImA = self -> WhatAmI(theObjects[i])
            
    ;---------------------------------------------------------------------
    ;Unknown Objects /////////////////////////////////////////////////////
    ;---------------------------------------------------------------------
        if ImA eq '' then begin
            print, FORMAT='(%"Object \"%s\" at index %i is not recognized. Cannot add.")', $
                   typename(theObjects[i]), i
            continue
        endif
            
    ;---------------------------------------------------------------------
    ;"Annotation" Objects ////////////////////////////////////////////////
    ;---------------------------------------------------------------------
        isData = isMember([*self.type.plot, *self.type.image], ImA) 
        if isData eq 0 then begin
            self -> MrIDL_Container::Add, theObjects[i], POSITION=thisIndex
            continue
        endif
        
    ;---------------------------------------------------------------------
    ;"Data" Objects //////////////////////////////////////////////////////
    ;---------------------------------------------------------------------
        
        ;Get the position and layout of the object. If either are undefined, they
        ;will be generated then set as properies of the current object.
        theObjects[i] -> GetProperty, POSITION=pos, LAYOUT=layout
        
        ;Get the "location" part of the layout.
        case n_elements(layout) of
            0: ;Do Nothing
            3: loc = layout[2]
            4: loc = layout[2:3]
            else: begin
                print, FOMRAT='(%"Cannot add object %s at index %i". Improper layout)', $
                       typename(theObjects[i]), i
                print, 'Layout = ', layout
                skip = 1
            endelse
        endcase
        if skip then continue

        ;Set the location and position of the new plot.
        self -> AddPositions, loc, pos
        
        ;Set the location and position as object properties
        theObjects[i] -> SetProperty, POSITION=pos, LAYOUT=[(*self.layout)[0:1], loc]
        
        ;Store the location and position if they were created.
        location[*,i] = temporary(loc)
        position[*,i] = temporary(pos)

        ;Add the object to the container.
        self -> MrIDL_Container::Add, theObjects[i], POSITION=thisIndex
    endfor
end


;+
;   The purpose of this method is to clear all objects from the list of objects being
;   displayed.
;
;   :Keywords:
;       DESTROY:                in, optional, type=boolean, default=1
;                               Destroy the objects being cleared.
;       DRAW:                   in, optional, type=boolean, default=0
;                               Call the Draw method after adding the legends to the list.
;       IMAGES_ONLY:            in, optional, type=boolean, default=0
;                               If set, only image objects will be cleared.
;       PLOTS_ONLY:             in, optional, type=boolean, default=0
;                               If set, only plot objects will be cleared.
;       
;-
pro MrPlotManager::Clear, $
DRAW = draw, $
DESTROY = destroy, $
IMAGES_ONLY = images_only, $
PLOTS_ONLY = plots_only
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
            
;---------------------------------------------------------------------
;Check Inputs ////////////////////////////////////////////////////////
;---------------------------------------------------------------------

    ;Defaults
    SetDefaultValue, destroy, 1, /BOOLEAN
    draw = keyword_set(draw)
    images_only = keyword_set(images_only)
    plots_only = keyword_set(plots_only)
            
;---------------------------------------------------------------------
;Plots Only? /////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    
    if keyword_set(plots_only) then begin
        ;Find which objects are being cleared from the master list.
        void = isMember(*self.plotObjects, *self.allObjects, iClear, NONMEMBER_INDS=iKeep)
        
        ;If all objects are plots, clear everything
        if n_elements(iKeep) eq 0 $
            then self -> Clear, DESTROY=destroy, DRAW=draw $
            else self -> RemovePlots, iClear, DESTROY=destroy, DRAW=draw
            
;---------------------------------------------------------------------
;Images Only? ////////////////////////////////////////////////////////
;---------------------------------------------------------------------

    endif else if keyword_set(images_only) then begin
        void = isMember(*self.imageObjects, *self.allObjects, iClear, NONMEMBER_INDS=iKeep)

        if n_elements(iKeep) eq 0 $
            then self -> Clear, DESTROY=destroy, DRAW=draw $
            else self -> RemoveImages, iClear, DESTROY=destroy, DRAW=draw
            
;---------------------------------------------------------------------
;Clear All ///////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    endif else begin
            
    ;---------------------------------------------------------------------
    ;Clear Superclasses //////////////////////////////////////////////////
    ;---------------------------------------------------------------------
    
        self -> MrAbstractImage::Clear, DESTROY=destroy
        self -> MrAbstractPlot::Clear, DESTROY=destroy
    
    ;---------------------------------------------------------------------
    ;Clear Master List ///////////////////////////////////////////////////
    ;---------------------------------------------------------------------
    
        ;If there are no objects to clear, then return
        if ptr_valid(self.allObjects) eq 0 then return
    
        ;Destroy the objects?
        if keyword_set(destroy) then obj_destroy, *self.allObjects
    
        ;Reset the pointer
        ptr_free, self.allObjects
        self.allObjects = ptr_new(/ALLOCATE_HEAP)
    
        ;Remove all locations and positions
        self -> SetPositions, /CLEAR
    
        ;Draw?
        if keyword_set(draw) then self -> Draw

    endelse
end


;+
;   Remove a Plot or Image object from the list of objects being displayed.
;
; :Params:
;       LOCATION:               in, optional, type=intarr(2\,N), default=[1\,1]
;                               The [col, row] location of the plot to replace
;
;   :Keywords:
;       ADJUST_LAYOUT:          in, optional, private, type=Boolean, default=0
;                               Sometimes holes are created in the plot layout when a
;                                   plots are added or removed. Set this keyword to remove
;                                   holes in the plot layout.
;       DESTROY:                in, optional, type=boolean, default=1
;                               Destroy the objects being replaced.
;       DRAW:                   in, optional, type=boolean, default=0
;                               Call the Draw method after adding the legends to the list.
;       LIST_INDEX              in, optional, type=boolean, default=0
;                               If set, then `LOCATION` is actually the index within at
;                                   which the plot is stored.
;       PLOT_INDEX:             in, optional, type=int, default=0
;                               If set, then `LOCATION` is actually the 1D plot index of
;                                   the plot. The upper-left-most plot has a plot index of
;                                   1, and the plot index increases as you go down the
;                                   column, then across the row.
;-
pro MrPlotManager::Remove, location, $
ADJUST_LAYOUT = adjust_layout, $
DESTROY = destroy, $
DRAW = draw, $
LIST_INDEX = list_index, $
PLOT_INDEX = plot_index
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    ;Defaults
    SetDefaultValue, draw, 0, /BOOLEAN
    SetDefaultValue, list_index, 0, /BOOLEAN
    SetDefaultValue, location, [1,1]
    SetDefaultValue, plot_index, 0, /BOOLEAN
    
    ;Convert LOCATION to a list index value if not one already
    if n_elements(location) ne 0 $
        then exists = self -> plotExists(location, iList, PLOT_INDEX=plot_index, $
                                         LIST_INDEX=list_index, /TO_LIST_INDEX) $
        else exists = 0
        
;---------------------------------------------------------------------
;Determine Which to Keep /////////////////////////////////////////////
;---------------------------------------------------------------------
    
    ;Make sure the plot exists
    if exists eq 0 then message, 'LOCATION does not exist. Cannot remove.'
    
    ;Find which plots are to be kept
    void = self -> plotExists(*self.plot_loc, all_list_index, /TO_LIST_INDEX)
    void = isMember(iList, all_list_index, NONMEMBER_INDS=ikeep)
        
;---------------------------------------------------------------------
;Remove From Superclasses First //////////////////////////////////////
;---------------------------------------------------------------------

    ;The objects to remove
    oRemove = (*self.allObjects)[iList]
    
    ;Plot Objects
    if ptr_valid(self.plotObjects) then begin
        ;Find the indices of objects to remove
        void = isMember(oRemove, *self.plotObjects, iRemove, N_MATCHES=nRemove)
        
        ;Remove them
        if nRemove ne 0 then self -> MrAbstractPlot::Remove, iRemove, DESTROY=0
    endif
    
    ;Image Objects -- same process
    if ptr_valid(self.imageObjects) then begin
        void = isMember(oRemove, *self.imageObjects, iRemove, N_MATCHES=nRemove)
        if nRemove ne 0 then self -> MrAbstractImage::Remove, iRemove, DESTROY=0
    endif
        
;---------------------------------------------------------------------
;Remove From Master List /////////////////////////////////////////////
;---------------------------------------------------------------------

    ;If no plots will remain after removing the desired plots...
    if n_elements(ikeep) eq 0 then begin

        ;Clear all positions and plot positions
        self -> Clear, DESTROY=destroy
        self -> ClearPositions
    
    ;If some plots will remain...
    endif else begin
    
        ;Destroy the objects being removed
        if keyword_set(destroy) then obj_destroy, (*self.allObjects)[iList]
        
        ;Remove the indicated objects
        *self.allObjects = (*self.allObjects)[ikeep]

        ;Remove their locations and positions
        self -> RemovePositions, iList, /LIST_INDEX, ADJUST_LAYOUT=adjust_layout
    endelse
        
;---------------------------------------------------------------------
;Draw ////////////////////////////////////////////////////////////////
;---------------------------------------------------------------------
    ;Draw?
    if keyword_set(draw) then self -> Draw
 
 end


;+
;   The purpose of this method is to provide a means of changing the overall layout of
;   the 2D plotting grid. In addition, individual plot locations and positions can be
;   altered or added by using the the following keywords::
;
;       SETLOCATION -   Set the location of an existing plot
;                           Fixed         -> Auto-Updating
;                           Auto-Updating -> Fixed
;                           Auto-Updating -> Auto-Updating
;
;       SETPOSITION -   Set the position of an existing plot
;                           Auto-Updating -> Fixed
;                           Fixed         -> Fixed
;
;       ADD         -   Add a new location and position to the lists.
;                           Auto-Updating
;                           Fixed
;
; :Params:
;       LOCATION:           in, optional, type=long
;                           The [col, row] location of the plot. Used with `ADD` and
;                               `SETLOCATION`.
;
; :Keywords:
;       ADD:                in, optional, type=Boolean, default=0
;                           If set, `LOCATION` and `POSITION` are appended to their
;                               respective lists. If `LOCATION` is not set, then a new
;                               one will be created. This new `LOCATION` will be "fixed"
;                               if `POSITION` is not present, and "auto-updating" if it is.
;                               New locations and positions will be returned via their
;                               respective parameter and keyword.
;       ADJUST_LAYOUT:      in, optional, private, type=Boolean, default=0
;                           Sometimes holes are created in the plot layout when an auto-
;                               updating plot's location changes. Set this keyword to
;                               remove holes in the plot layout.
;       LAYOUT:             in, out, optional, type=intarr(2)
;                           A two-element vector [col, row] indicating the number of
;                               columns and rows in the plot layout. If set, the layout
;                               and positions will be updated. Furthermore, if the layout
;                               changes as a result of adding, moving, or fixing plots
;                               from the auto-updating grid, then the new layout will be
;                               returned.
;       LIST_INDEX:         in, optional, type=Boolean, default=0
;                           Indicate that `LOCATION` is the index location within the
;                               internal data lists of the plot whose position is to
;                               be altered. To obtain the list index, use the
;                               "plotsPresent" method.
;       POSITION:           out, optional, type=fltarr(4)
;                           The lower-left and upper-right corners of a plot in normal
;                               coordinates. If `SETLOCATION` is in use, then this is the
;                               new position of the plot indicated by `LOCATION`.
;       SETLOCATION:        in, optional, type=lonarr(2)
;                           Use this kewyord to set the [col, row] location of the plot
;                               indicated by `LOCATION`::
;                                   `LOCATION`[0] > 0, `SETLOCATION[0] < 0 
;                                       An auto-updating plot will become fixed at
;                                       its present position.
;                                   `LOCATION`[0] < 0, `SETLOCATION`[0] > 0 
;                                       A fixed plot will be put into the auto-updating
;                                       grid at the location indicated.
;                                   `LOCATION`[0] > 0, `SETLOCATION`[0] > 0 
;                                       An auto-updating plot will be moved within the 
;                                       grid to the location indicated.
;                                   `LOCATION`[0] < 0, `SETLOCATION`[0] < 0 
;                                       Ignored. A fixed plot is fixed no matter what.
;       SETPOSITION:        in, optional, type=fltarr(4)
;                           A four-element vector in the form [x0, y0, x1, y1] specifying
;                               the location of the lower right [x0, y0] and upper-left
;                               [x1, y1] corners of a plot. If set, then the plot given
;                               by `LOCATION` will have its position changed to SETPOSITION.
;                               If `LOCATION` is that of an auto-updating plot, it will
;                               become fixed. If a location has been changed, it will be
;                               returned in `SETLOCATION`.
;       _REF_EXTRA:         in, optional, type=Structure
;                           Any keyword accepted by MrPlotLayout.pro
;
; :Uses:
;   Uses the following external programs::
;       MrPlotLayout.pro
;-
pro MrPlotManager::ApplyPositions
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return
    endif
    
    ;First deal with the superclass
    self -> MrPlotLayout::ApplyPositions
    
;---------------------------------------------------------------------
;Reposition Plots ////////////////////////////////////////////////////
;---------------------------------------------------------------------
    ;
    ; From the Plot method, the following actions have been completed:
    ;   1) Adjusted locations and positions of each plot
    ;   2) Applied the new positions to each plot
    ;   3) Adjusted the layout
    ;
    ; Now we need to do the following:
    ;   4) Update the positions in the allObjects list.
    ;   5) Update the colorbar positions.
    ;
    isData = [*self.type.plot, *self.type.image]
    dataObjs = self -> Get(/ALL, ISA=isData, POSITION=iData, COUNT=nData)
    
    
    ;If there are no plots, then there is nothing to reposition.
    if nData eq 0 then return

    ;Update the position of each plot.
    for i = 0, nData - 1 do $
        (*self.allObjects)[i] -> SetProperty, POSITION=(*self.plot_positions)[*,i]
end


;+
;   Determine which type of object was given.
;
; :Params:
;       OBJREF:             in, required, type=Object
;                           An object reference whose "type" is to be determined. Will
;                               tell you if the object is a Plot or Image.
;
; :Returns:
;       IMA:                out, required, type=string
;                           The type of object that was passed. This is determined by
;                               scanning all of the different lists of objects to find
;                               a match. If no match is found, the empty string is
;                               returned.
;-
function MrPlotManager::WhatAmI, objRef
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, ''
    endif
    
    ;How many objects are there?
    nObjs = self -> Count()
    if nObjs eq 0 then return, ''
    
    ;Is this object in the container?
    tf_contained = self -> IsContained(objRef)
    if tf_contained eq 0 then return, ''
    
    ;What type of object is it?
    className = typename(objRef)
    case className of
        'MRPLOTOBJECT':  ImA = 'PLOT'
        'MRIMAGEOBJECT': ImA = 'IMAGE'
        'WECOLORBAR':    ImA = 'COLORBAR'
        'WETEXT':        ImA = 'TEXT'
        'WEARROW':       ImA = 'ARROW'
        'WEOVERPLOT':    ImA = 'OVERPLOT'
        'WELEGENDITEM':  ImA = 'LEGEND'
        'WEAXIS':        ImA = 'AXIS'
        else:            ImA = ''
    endcase
    
    return, ImA
end


;+
;   The purpose of this method is to create a structure of supported classes for each
;   graphics type.
;-
pro MrPlotManager::Config
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, ''
    endif
    
    ;Class names of the supported graphics types
    types = { plot: ['PLOT', 'MRPLOTOBJECT'], $
              image: ['IMAGE', 'MRIMAGEOBJECT'], $
              colorbar: ['WECOLORBAR'], $
              axis: ['WEAXIS'], $
              legend: ['WELEGENDITEM'], $
              arrow: ['WEARROW'], $
              text: ['WETEXT'], $
              overplot: ['WEOVERPLOT'], $
            }
    
    ;Store them as a class property
    self.types = ptr_new(types)

end


;+
;   Clean up after the object is destroy
;-
pro MrPlotManager::cleanup
    compile_opt idl2
    
    ;Destroy all weLegendItem objects
    self -> MrAbstractPlot::Cleanup
    self -> MrAbstractImage::Cleanup
    self -> MrPlotLayout::Cleanup
    
    ;Free pointers
    ptr_free, self.type
end


;+
;   The initialization method.
;
; :Keywords:
;       _REF_EXTRA:                 in, optional, type=structure
;                                   Any keyword accepted by MrPlotLayout__define is also
;                                       accepted for keyword inheritance.
;-
function MrPlotManager::init, $
_REF_EXTRA = extra
    compile_opt idl2
    
    ;Error handling
    catch, the_error
    if the_error ne 0 then begin
        catch, /cancel
        void = error_message()
        return, 0
    endif

    ;Setup the plot window
    if self -> MrPlotLayout::init(_STRICT_EXTRA=extra) eq 0 then return, 0
    
    ;Configure the object
    self -> config
    
    return, 1
end


;+
;   Object class definition
;
; :Params:
;       CLASS:          out, optional, type=structure
;                       The class definition structure.
;-
pro MrPlotManager__define, class
    compile_opt idl2
    
    define = { MrPlotManager, $
               inherits MrIDL_Container, $      ;An object container
               inherits MrCreateGraphic, $      ;Plots, Images, Colorbars, Text, Arrows, etc.
               inherits MrPlotLayout, $         ;Manage plot layout
               type = ptr_new() $               ;Supported graphics types.
             }
end